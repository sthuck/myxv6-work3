!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALT	kbd.h	11;"	d
AS	Makefile	/^AS = $(TOOLPREFIX)gas$/;"	m
ASFLAGS	Makefile	/^ASFLAGS = -m32 -gdwarf-2 -Wa,-divide$/;"	m
ASSERT	lapic.c	23;"	d	file:
Align	umalloc.c	/^typedef long Align;$/;"	t	file:
BACK	sh.c	12;"	d	file:
BACKSPACE	console.c	125;"	d	file:
BBLOCK	fs.h	46;"	d
BCAST	lapic.c	26;"	d	file:
BPB	fs.h	43;"	d
BSIZE	fs.h	12;"	d
BUSY	lapic.c	27;"	d	file:
B_BUSY	buf.h	10;"	d
B_DIRTY	buf.h	12;"	d
B_VALID	buf.h	11;"	d
C	console.c	185;"	d	file:
C	kbd.h	32;"	d
C	kernel.asm	/^#define C(x)  ((x)-'@')  \/\/ Control-x$/;"	d
CAPSLOCK	kbd.h	13;"	d
CC	Makefile	/^CC = $(TOOLPREFIX)gcc$/;"	m
CC	Makefile	/^CC = $(TOOLPREFIX)gcc-4.6$/;"	m
CFLAGS	Makefile	/^CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -Wall -MD -ggdb -m32 -Werror -fno-omit-frame-pointer$/;"	m
COM1	uart.c	14;"	d	file:
CONSOLE	file.h	38;"	d
CPUS	Makefile	/^CPUS := 1$/;"	m
CR0_AM	mmu.h	35;"	d
CR0_CD	mmu.h	37;"	d
CR0_EM	mmu.h	30;"	d
CR0_ET	mmu.h	32;"	d
CR0_MP	mmu.h	29;"	d
CR0_NE	mmu.h	33;"	d
CR0_NW	mmu.h	36;"	d
CR0_PE	mmu.h	28;"	d
CR0_PG	mmu.h	38;"	d
CR0_TS	mmu.h	31;"	d
CR0_WP	mmu.h	34;"	d
CR4_PSE	mmu.h	40;"	d
CRTPORT	console.c	126;"	d	file:
CRTPORT	kernel.asm	/^#define CRTPORT 0x3d4$/;"	d
CTL	kbd.h	10;"	d
DEASSERT	lapic.c	24;"	d	file:
DELIVS	lapic.c	22;"	d	file:
DEVSPACE	memlayout.h	5;"	d
DIRSIZ	fs.h	49;"	d
DPL_USER	mmu.h	79;"	d
Disassembly	bootblock.asm	/^Disassembly of section .text:$/;"	l
Disassembly	cat.asm	/^Disassembly of section .text:$/;"	l
Disassembly	echo.asm	/^Disassembly of section .text:$/;"	l
Disassembly	entryother.asm	/^Disassembly of section .text:$/;"	l
Disassembly	grep.asm	/^Disassembly of section .text:$/;"	l
Disassembly	init.asm	/^Disassembly of section .text:$/;"	l
Disassembly	initcode.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kernel.asm	/^Disassembly of section .text:$/;"	l
Disassembly	kill.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ln.asm	/^Disassembly of section .text:$/;"	l
Disassembly	ls.asm	/^Disassembly of section .text:$/;"	l
Disassembly	mkdir.asm	/^Disassembly of section .text:$/;"	l
Disassembly	rm.asm	/^Disassembly of section .text:$/;"	l
Disassembly	sh.asm	/^Disassembly of section .text:$/;"	l
Disassembly	wc.asm	/^Disassembly of section .text:$/;"	l
Disassembly	zombie.asm	/^Disassembly of section .text:$/;"	l
E0ESC	kbd.h	17;"	d
ELF_MAGIC	elf.h	3;"	d
ELF_PROG_FLAG_EXEC	elf.h	40;"	d
ELF_PROG_FLAG_READ	elf.h	42;"	d
ELF_PROG_FLAG_WRITE	elf.h	41;"	d
ELF_PROG_LOAD	elf.h	37;"	d
EMBRYO	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
ENABLE	lapic.c	17;"	d	file:
EOI	lapic.c	15;"	d	file:
ERROR	lapic.c	36;"	d	file:
ESR	lapic.c	18;"	d	file:
EXEC	sh.c	8;"	d	file:
EXTMEM	memlayout.h	3;"	d
EXTRA	Makefile	/^EXTRA=\\$/;"	m
FD_INODE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FD_NONE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FD_PIPE	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	e	enum:file::__anon5
FILES	Makefile	/^FILES = $(shell grep -v '^\\#' runoff.list)$/;"	m
FIXED	lapic.c	28;"	d	file:
FL_AC	mmu.h	22;"	d
FL_AF	mmu.h	7;"	d
FL_CF	mmu.h	5;"	d
FL_DF	mmu.h	12;"	d
FL_ID	mmu.h	25;"	d
FL_IF	mmu.h	11;"	d
FL_IOPL_0	mmu.h	15;"	d
FL_IOPL_1	mmu.h	16;"	d
FL_IOPL_2	mmu.h	17;"	d
FL_IOPL_3	mmu.h	18;"	d
FL_IOPL_MASK	mmu.h	14;"	d
FL_NT	mmu.h	19;"	d
FL_OF	mmu.h	13;"	d
FL_PF	mmu.h	6;"	d
FL_RF	mmu.h	20;"	d
FL_SF	mmu.h	9;"	d
FL_TF	mmu.h	10;"	d
FL_VIF	mmu.h	23;"	d
FL_VIP	mmu.h	24;"	d
FL_VM	mmu.h	21;"	d
FL_ZF	mmu.h	8;"	d
GDBPORT	Makefile	/^GDBPORT = $(shell expr `id -u` % 5000 + 25000)$/;"	m
Header	umalloc.c	/^typedef union header Header;$/;"	t	typeref:union:header	file:
IBLOCK	fs.h	40;"	d
ICRHI	lapic.c	29;"	d	file:
ICRLO	lapic.c	19;"	d	file:
ID	lapic.c	12;"	d	file:
IDE_BSY	ide.c	14;"	d	file:
IDE_CMD_READ	ide.c	19;"	d	file:
IDE_CMD_WRITE	ide.c	20;"	d	file:
IDE_DF	ide.c	16;"	d	file:
IDE_DRDY	ide.c	15;"	d	file:
IDE_ERR	ide.c	17;"	d	file:
INIT	lapic.c	20;"	d	file:
INPUT_BUF	console.c	176;"	d	file:
INT_ACTIVELOW	ioapic.c	22;"	d	file:
INT_DISABLED	ioapic.c	20;"	d	file:
INT_LEVEL	ioapic.c	21;"	d	file:
INT_LOGICAL	ioapic.c	23;"	d	file:
IOAPIC	ioapic.c	9;"	d	file:
IO_PIC1	picirq.c	8;"	d	file:
IO_PIC2	picirq.c	9;"	d	file:
IO_RTC	lapic.c	133;"	d	file:
IO_TIMER1	timer.c	10;"	d	file:
IPB	fs.h	37;"	d
IRQ_COM1	traps.h	34;"	d
IRQ_ERROR	traps.h	36;"	d
IRQ_IDE	traps.h	35;"	d
IRQ_KBD	traps.h	33;"	d
IRQ_SLAVE	picirq.c	11;"	d	file:
IRQ_SPURIOUS	traps.h	37;"	d
IRQ_TIMER	traps.h	32;"	d
I_BUSY	file.h	26;"	d
I_VALID	file.h	27;"	d
KBDATAP	kbd.h	5;"	d
KBSTATP	kbd.h	3;"	d
KBS_DIB	kbd.h	4;"	d
KERNBASE	kernel.asm	/^#define KERNBASE 0x80000000         \/\/ First kernel virtual address$/;"	d
KERNBASE	memlayout.h	8;"	d
KERNLINK	kernel.asm	/^#define KERNLINK (KERNBASE+EXTMEM)  \/\/ Address where kernel is linked$/;"	d
KERNLINK	memlayout.h	9;"	d
KEY_DEL	kbd.h	29;"	d
KEY_DN	kbd.h	23;"	d
KEY_END	kbd.h	21;"	d
KEY_HOME	kbd.h	20;"	d
KEY_INS	kbd.h	28;"	d
KEY_LF	kbd.h	24;"	d
KEY_PGDN	kbd.h	27;"	d
KEY_PGUP	kbd.h	26;"	d
KEY_RT	kbd.h	25;"	d
KEY_UP	kbd.h	22;"	d
KSTACKSIZE	param.h	2;"	d
LD	Makefile	/^LD = $(TOOLPREFIX)ld$/;"	m
LEVEL	lapic.c	25;"	d	file:
LINT0	lapic.c	34;"	d	file:
LINT1	lapic.c	35;"	d	file:
LIST	sh.c	11;"	d	file:
LOGSIZE	param.h	11;"	d
MASKED	lapic.c	37;"	d	file:
MAXARG	param.h	10;"	d
MAXARGS	sh.c	14;"	d	file:
MAXFILE	fs.h	24;"	d
MAX_CONDS	kthread.h	3;"	d
MAX_MUTEXES	kthread.h	2;"	d
MAX_THREAD	uthread.h	7;"	d
MEMFSOBJS	Makefile	/^MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o$/;"	m
MPBOOT	mp.h	34;"	d
MPBUS	mp.h	50;"	d
MPIOAPIC	mp.h	51;"	d
MPIOINTR	mp.h	52;"	d
MPLINTR	mp.h	53;"	d
MPPROC	mp.h	49;"	d
NBUF	param.h	6;"	d
NCPU	param.h	3;"	d
NDEV	param.h	8;"	d
NDIRECT	fs.h	22;"	d
NELEM	defs.h	181;"	d
NFILE	param.h	5;"	d
NINDIRECT	fs.h	23;"	d
NINODE	param.h	7;"	d
NO	kbd.h	7;"	d
NOFILE	param.h	4;"	d
NPDENTRIES	mmu.h	121;"	d
NPROC	param.h	1;"	d
NPTENTRIES	mmu.h	122;"	d
NSEGS	proc.h	2;"	d
NUMLOCK	kbd.h	14;"	d
NUMSIG	signal.h	1;"	d
OBJCOPY	Makefile	/^OBJCOPY = $(TOOLPREFIX)objcopy$/;"	m
OBJDUMP	Makefile	/^OBJDUMP = $(TOOLPREFIX)objdump$/;"	m
OBJS	Makefile	/^OBJS = \\$/;"	m
O_CREATE	fcntl.h	4;"	d
O_RDONLY	fcntl.h	1;"	d
O_RDWR	fcntl.h	3;"	d
O_WRONLY	fcntl.h	2;"	d
P2V	memlayout.h	19;"	d
P2V_WO	memlayout.h	22;"	d
PCINT	lapic.c	33;"	d	file:
PDX	mmu.h	112;"	d
PDXSHIFT	mmu.h	127;"	d
PERIODIC	lapic.c	32;"	d	file:
PGADDR	mmu.h	118;"	d
PGROUNDDOWN	mmu.h	130;"	d
PGROUNDUP	mmu.h	129;"	d
PGSHIFT	mmu.h	125;"	d
PGSIZE	mmu.h	123;"	d
PHYSTOP	memlayout.h	4;"	d
PIPE	sh.c	10;"	d	file:
PIPESIZE	pipe.c	10;"	d	file:
PRINT	Makefile	/^PRINT = runoff.list runoff.spec README toc.hdr toc.ftr $(FILES)$/;"	m
PTE_A	mmu.h	138;"	d
PTE_ADDR	mmu.h	144;"	d
PTE_D	mmu.h	139;"	d
PTE_MBZ	mmu.h	141;"	d
PTE_P	mmu.h	133;"	d
PTE_PCD	mmu.h	137;"	d
PTE_PS	mmu.h	140;"	d
PTE_PWT	mmu.h	136;"	d
PTE_U	mmu.h	135;"	d
PTE_W	mmu.h	134;"	d
PTX	mmu.h	115;"	d
PTXSHIFT	mmu.h	126;"	d
QEMU	Makefile	/^QEMU = $(shell if which qemu > \/dev\/null; \\$/;"	m
QEMU	Makefile	/^QEMU = qemu-system-i386$/;"	m
QEMUGDB	Makefile	/^QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \\$/;"	m
QEMUOPTS	Makefile	/^QEMUOPTS = -hdb fs.img xv6.img -smp $(CPUS) -m 512 $(QEMUEXTRA) -net none$/;"	m
REDIR	sh.c	9;"	d	file:
REG_ID	ioapic.c	11;"	d	file:
REG_TABLE	ioapic.c	13;"	d	file:
REG_VER	ioapic.c	12;"	d	file:
ROOTDEV	param.h	9;"	d
ROOTINO	fs.h	11;"	d
RUNNABLE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
RUNNING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
SCROLLLOCK	kbd.h	15;"	d
SECTSIZE	bootmain.c	13;"	d	file:
SEG	mmu.h	69;"	d
SEG16	mmu.h	73;"	d
SEG_ASM	asm.h	11;"	d
SEG_KCODE	mmu.h	42;"	d
SEG_KCPU	mmu.h	44;"	d
SEG_KDATA	mmu.h	43;"	d
SEG_NULLASM	asm.h	5;"	d
SEG_TSS	mmu.h	47;"	d
SEG_UCODE	mmu.h	45;"	d
SEG_UDATA	mmu.h	46;"	d
SETGATE	mmu.h	212;"	d
SHIFT	kbd.h	9;"	d
SIGABRT	signal.h	3;"	d
SIGALRM	signal.h	4;"	d
SIGBUS	signal.h	5;"	d
SIGCHLD	signal.h	6;"	d
SIGCONT	signal.h	7;"	d
SIGFPE	signal.h	8;"	d
SIGHUP	signal.h	9;"	d
SIGILL	signal.h	10;"	d
SIGINT	signal.h	11;"	d
SIGKILL	signal.h	12;"	d
SIGPIPE	signal.h	13;"	d
SIGPOLL	signal.h	23;"	d
SIGPROF	signal.h	24;"	d
SIGQUIT	signal.h	14;"	d
SIGSEGV	signal.h	15;"	d
SIGSTOP	signal.h	16;"	d
SIGSYS	signal.h	25;"	d
SIGTERM	signal.h	17;"	d
SIGTRAP	signal.h	26;"	d
SIGTSTP	signal.h	18;"	d
SIGTTIN	signal.h	19;"	d
SIGTTOU	signal.h	20;"	d
SIGURG	signal.h	27;"	d
SIGUSR1	signal.h	21;"	d
SIGUSR2	signal.h	22;"	d
SIGVTALRM	signal.h	28;"	d
SIGXCPU	signal.h	29;"	d
SIGXFSZ	signal.h	30;"	d
SLEEPING	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
STACK_SIZE	uthread.h	6;"	d
STARTUP	lapic.c	21;"	d	file:
STA_A	asm.h	21;"	d
STA_A	mmu.h	87;"	d
STA_C	asm.h	18;"	d
STA_C	mmu.h	84;"	d
STA_E	asm.h	17;"	d
STA_E	mmu.h	83;"	d
STA_R	asm.h	20;"	d
STA_R	mmu.h	86;"	d
STA_W	asm.h	19;"	d
STA_W	mmu.h	85;"	d
STA_X	asm.h	16;"	d
STA_X	mmu.h	82;"	d
STS_CG16	mmu.h	93;"	d
STS_CG32	mmu.h	99;"	d
STS_IG16	mmu.h	95;"	d
STS_IG32	mmu.h	100;"	d
STS_LDT	mmu.h	91;"	d
STS_T16A	mmu.h	90;"	d
STS_T16B	mmu.h	92;"	d
STS_T32A	mmu.h	97;"	d
STS_T32B	mmu.h	98;"	d
STS_TG	mmu.h	94;"	d
STS_TG16	mmu.h	96;"	d
STS_TG32	mmu.h	101;"	d
SVR	lapic.c	16;"	d	file:
SYSCALL	usys.S	/^#define SYSCALL(name) \\$/;"	d
SYS_chdir	syscall.h	10;"	d
SYS_close	syscall.h	23;"	d
SYS_dup	syscall.h	11;"	d
SYS_exec	syscall.h	8;"	d
SYS_exit	syscall.h	3;"	d
SYS_fork	syscall.h	2;"	d
SYS_fstat	syscall.h	9;"	d
SYS_getpid	syscall.h	12;"	d
SYS_kill	syscall.h	7;"	d
SYS_link	syscall.h	21;"	d
SYS_mkdir	syscall.h	22;"	d
SYS_mknod	syscall.h	19;"	d
SYS_open	syscall.h	17;"	d
SYS_pipe	syscall.h	5;"	d
SYS_read	syscall.h	6;"	d
SYS_sbrk	syscall.h	13;"	d
SYS_sleep	syscall.h	14;"	d
SYS_unlink	syscall.h	20;"	d
SYS_uptime	syscall.h	15;"	d
SYS_wait	syscall.h	4;"	d
SYS_write	syscall.h	18;"	d
TCCR	lapic.c	39;"	d	file:
TDCR	lapic.c	40;"	d	file:
THREAD_QUANTA	uthread.h	1;"	d
TICR	lapic.c	38;"	d	file:
TIMER	lapic.c	30;"	d	file:
TIMER_16BIT	kernel.asm	/^#define TIMER_16BIT     0x30    \/\/ r\/w counter 16 bits, LSB first$/;"	d
TIMER_16BIT	timer.c	22;"	d	file:
TIMER_DIV	timer.c	17;"	d	file:
TIMER_FREQ	timer.c	16;"	d	file:
TIMER_MODE	timer.c	19;"	d	file:
TIMER_RATEGEN	kernel.asm	/^#define TIMER_RATEGEN   0x04    \/\/ mode 2, rate generator$/;"	d
TIMER_RATEGEN	timer.c	21;"	d	file:
TIMER_SEL0	timer.c	20;"	d	file:
TOOLPREFIX	Makefile	/^TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >\/dev\/null 2>&1; \\$/;"	m
TPR	lapic.c	14;"	d	file:
T_ALIGN	traps.h	21;"	d
T_BOUND	traps.h	9;"	d
T_BRKPT	traps.h	7;"	d
T_DBLFLT	traps.h	12;"	d
T_DEBUG	traps.h	5;"	d
T_DEFAULT	traps.h	28;"	d
T_DEV	stat.h	3;"	d
T_DEVICE	traps.h	11;"	d
T_DIR	stat.h	1;"	d
T_DIVIDE	traps.h	4;"	d
T_FILE	stat.h	2;"	d
T_FPERR	traps.h	20;"	d
T_FREE	uthread.h	/^typedef enum  {T_FREE, T_RUNNING, T_RUNNABLE, T_SLEEPING} uthread_state;$/;"	e	enum:__anon10
T_GPFLT	traps.h	17;"	d
T_ILLOP	traps.h	10;"	d
T_IRQ0	traps.h	30;"	d
T_MCHK	traps.h	22;"	d
T_NMI	traps.h	6;"	d
T_OFLOW	traps.h	8;"	d
T_PGFLT	traps.h	18;"	d
T_RUNNABLE	uthread.h	/^typedef enum  {T_FREE, T_RUNNING, T_RUNNABLE, T_SLEEPING} uthread_state;$/;"	e	enum:__anon10
T_RUNNING	uthread.h	/^typedef enum  {T_FREE, T_RUNNING, T_RUNNABLE, T_SLEEPING} uthread_state;$/;"	e	enum:__anon10
T_SEGNP	traps.h	15;"	d
T_SIMDERR	traps.h	23;"	d
T_SLEEPING	uthread.h	/^typedef enum  {T_FREE, T_RUNNING, T_RUNNABLE, T_SLEEPING} uthread_state;$/;"	e	enum:__anon10
T_STACK	traps.h	16;"	d
T_SYSCALL	traps.h	27;"	d
T_TSS	traps.h	14;"	d
ULIB	Makefile	/^ULIB = ulib.o usys.o printf.o umalloc.o$/;"	m
UNUSED	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
UPROGS	Makefile	/^UPROGS=\\$/;"	m
V2P	memlayout.h	18;"	d
V2P_WO	memlayout.h	21;"	d
VER	lapic.c	13;"	d	file:
X1	lapic.c	31;"	d	file:
ZOMBIE	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	e	enum:procstate
_cat	cat.asm	/^_cat:     file format elf32-i386$/;"	l
_echo	echo.asm	/^_echo:     file format elf32-i386$/;"	l
_grep	grep.asm	/^_grep:     file format elf32-i386$/;"	l
_init	init.asm	/^_init:     file format elf32-i386$/;"	l
_kill	kill.asm	/^_kill:     file format elf32-i386$/;"	l
_ln	ln.asm	/^_ln:     file format elf32-i386$/;"	l
_ls	ls.asm	/^_ls:     file format elf32-i386$/;"	l
_mkdir	mkdir.asm	/^_mkdir:     file format elf32-i386$/;"	l
_rm	rm.asm	/^_rm:     file format elf32-i386$/;"	l
_sh	sh.asm	/^_sh:     file format elf32-i386$/;"	l
_start	entry.S	/^_start = V2P_WO(entry)$/;"	d
_wc	wc.asm	/^_wc:     file format elf32-i386$/;"	l
_zombie	zombie.asm	/^_zombie:     file format elf32-i386$/;"	l
a	initcode.asm	/^   a:	6a 00                	push   $0x0$/;"	l
a	kernel.asm	/^    a = (uint*)bp->data;$/;"	d
a	kernel.asm	/^  a = (char*)PGROUNDDOWN((uint)va);$/;"	d
a	kernel.asm	/^  a = PGROUNDUP(newsz);$/;"	d
a	kernel.asm	/^  a = PGROUNDUP(oldsz);$/;"	d
a	ls.asm	/^   a:	89 04 24             	mov    %eax,(%esp)$/;"	l
a	sh.asm	/^       a:	75 05                	jne    11 <runcmd+0x11>$/;"	l
a0	echo.asm	/^  a0:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a0	grep.asm	/^  a0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
a0	ln.asm	/^  a0:	c3                   	ret    $/;"	l
a0	sh.asm	/^      a0:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
a0	wc.asm	/^  a0:	e8 9b 03 00 00       	call   440 <read>$/;"	l
a0	zombie.asm	/^  a0:	38 c2                	cmp    %al,%dl$/;"	l
a00	grep.asm	/^ a00:	89 04 24             	mov    %eax,(%esp)$/;"	l
a01	ls.asm	/^ a01:	83 c0 08             	add    $0x8,%eax$/;"	l
a01	sh.asm	/^     a01:	83 ec 28             	sub    $0x28,%esp$/;"	l
a03	grep.asm	/^ a03:	e8 d8 fe ff ff       	call   8e0 <free>$/;"	l
a04	ls.asm	/^ a04:	89 04 24             	mov    %eax,(%esp)$/;"	l
a04	sh.asm	/^     a04:	c7 44 24 08 3f 15 00 	movl   $0x153f,0x8(%esp)$/;"	l
a07	ls.asm	/^ a07:	e8 d8 fe ff ff       	call   8e4 <free>$/;"	l
a08	grep.asm	/^ a08:	a1 08 0e 00 00       	mov    0xe08,%eax$/;"	l
a0b	sh.asm	/^     a0b:	00 $/;"	l
a0c	ls.asm	/^ a0c:	a1 00 0e 00 00       	mov    0xe00,%eax$/;"	l
a0c	sh.asm	/^     a0c:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a0d	grep.asm	/^ a0d:	c9                   	leave  $/;"	l
a0e	grep.asm	/^ a0e:	c3                   	ret    $/;"	l
a0f	grep.asm	/^ a0f:	55                   	push   %ebp$/;"	l
a0f	sh.asm	/^     a0f:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a1	kill.asm	/^  a1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a1	ln.asm	/^  a1:	55                   	push   %ebp$/;"	l
a10	grep.asm	/^ a10:	89 e5                	mov    %esp,%ebp$/;"	l
a11	ls.asm	/^ a11:	c9                   	leave  $/;"	l
a12	grep.asm	/^ a12:	83 ec 28             	sub    $0x28,%esp$/;"	l
a12	ls.asm	/^ a12:	c3                   	ret    $/;"	l
a13	ls.asm	/^ a13:	55                   	push   %ebp$/;"	l
a13	sh.asm	/^     a13:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a14	ls.asm	/^ a14:	89 e5                	mov    %esp,%ebp$/;"	l
a15	grep.asm	/^ a15:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a16	ls.asm	/^ a16:	83 ec 28             	sub    $0x28,%esp$/;"	l
a16	sh.asm	/^     a16:	89 04 24             	mov    %eax,(%esp)$/;"	l
a18	grep.asm	/^ a18:	83 c0 07             	add    $0x7,%eax$/;"	l
a19	ls.asm	/^ a19:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a19	sh.asm	/^     a19:	e8 5f fc ff ff       	call   67d <peek>$/;"	l
a1b	grep.asm	/^ a1b:	c1 e8 03             	shr    $0x3,%eax$/;"	l
a1c	ls.asm	/^ a1c:	83 c0 07             	add    $0x7,%eax$/;"	l
a1e	grep.asm	/^ a1e:	83 c0 01             	add    $0x1,%eax$/;"	l
a1e	sh.asm	/^     a1e:	85 c0                	test   %eax,%eax$/;"	l
a1f	ls.asm	/^ a1f:	c1 e8 03             	shr    $0x3,%eax$/;"	l
a2	ln.asm	/^  a2:	89 e5                	mov    %esp,%ebp$/;"	l
a2	mkdir.asm	/^  a2:	89 55 10             	mov    %edx,0x10(%ebp)$/;"	l
a2	rm.asm	/^  a2:	89 55 10             	mov    %edx,0x10(%ebp)$/;"	l
a2	zombie.asm	/^  a2:	74 de                	je     82 <strcmp+0x5>$/;"	l
a20	sh.asm	/^     a20:	75 0c                	jne    a2e <parseblock+0x30>$/;"	l
a21	grep.asm	/^ a21:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
a22	ls.asm	/^ a22:	83 c0 01             	add    $0x1,%eax$/;"	l
a22	sh.asm	/^     a22:	c7 04 24 41 15 00 00 	movl   $0x1541,(%esp)$/;"	l
a24	grep.asm	/^ a24:	a1 08 0e 00 00       	mov    0xe08,%eax$/;"	l
a25	ls.asm	/^ a25:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
a28	ls.asm	/^ a28:	a1 00 0e 00 00       	mov    0xe00,%eax$/;"	l
a29	grep.asm	/^ a29:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a29	sh.asm	/^     a29:	e8 2c f9 ff ff       	call   35a <panic>$/;"	l
a2c	grep.asm	/^ a2c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
a2d	ls.asm	/^ a2d:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
a2e	sh.asm	/^     a2e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)$/;"	l
a3	echo.asm	/^  a3:	88 10                	mov    %dl,(%eax)$/;"	l
a3	ls.asm	/^  a3:	b8 e8 0d 00 00       	mov    $0xde8,%eax$/;"	l
a30	grep.asm	/^ a30:	75 23                	jne    a55 <malloc+0x46>$/;"	l
a30	ls.asm	/^ a30:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
a32	grep.asm	/^ a32:	c7 45 f0 00 0e 00 00 	movl   $0xe00,-0x10(%ebp)$/;"	l
a34	ls.asm	/^ a34:	75 23                	jne    a59 <malloc+0x46>$/;"	l
a35	sh.asm	/^     a35:	00 $/;"	l
a36	ls.asm	/^ a36:	c7 45 f0 f8 0d 00 00 	movl   $0xdf8,-0x10(%ebp)$/;"	l
a36	sh.asm	/^     a36:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)$/;"	l
a39	grep.asm	/^ a39:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a3c	grep.asm	/^ a3c:	a3 08 0e 00 00       	mov    %eax,0xe08$/;"	l
a3d	ls.asm	/^ a3d:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a3d	sh.asm	/^     a3d:	00 $/;"	l
a3e	sh.asm	/^     a3e:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a4	grep.asm	/^  a4:	7e 2b                	jle    d1 <grep+0xd1>$/;"	l
a4	init.asm	/^  a4:	e8 cf 02 00 00       	call   378 <exit>$/;"	l
a4	kill.asm	/^  a4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
a4	ln.asm	/^  a4:	83 ec 10             	sub    $0x10,%esp$/;"	l
a4	sh.asm	/^      a4:	89 04 24             	mov    %eax,(%esp)$/;"	l
a4	zombie.asm	/^  a4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a40	ls.asm	/^ a40:	a3 00 0e 00 00       	mov    %eax,0xe00$/;"	l
a41	grep.asm	/^ a41:	a1 08 0e 00 00       	mov    0xe08,%eax$/;"	l
a41	sh.asm	/^     a41:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a45	ls.asm	/^ a45:	a1 00 0e 00 00       	mov    0xe00,%eax$/;"	l
a45	sh.asm	/^     a45:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a46	grep.asm	/^ a46:	a3 00 0e 00 00       	mov    %eax,0xe00$/;"	l
a48	sh.asm	/^     a48:	89 04 24             	mov    %eax,(%esp)$/;"	l
a4a	ls.asm	/^ a4a:	a3 f8 0d 00 00       	mov    %eax,0xdf8$/;"	l
a4b	grep.asm	/^ a4b:	c7 05 04 0e 00 00 00 	movl   $0x0,0xe04$/;"	l
a4b	sh.asm	/^     a4b:	e8 e5 fa ff ff       	call   535 <gettoken>$/;"	l
a4f	ls.asm	/^ a4f:	c7 05 fc 0d 00 00 00 	movl   $0x0,0xdfc$/;"	l
a5	cat.asm	/^  a5:	00 $/;"	l
a5	echo.asm	/^  a5:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a5	mkdir.asm	/^  a5:	5b                   	pop    %ebx$/;"	l
a5	rm.asm	/^  a5:	5b                   	pop    %ebx$/;"	l
a5	wc.asm	/^  a5:	89 45 e0             	mov    %eax,-0x20(%ebp)$/;"	l
a50	sh.asm	/^     a50:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a52	grep.asm	/^ a52:	00 00 00 $/;"	l
a53	sh.asm	/^     a53:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a55	grep.asm	/^ a55:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a56	ls.asm	/^ a56:	00 00 00 $/;"	l
a57	sh.asm	/^     a57:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a58	grep.asm	/^ a58:	8b 00                	mov    (%eax),%eax$/;"	l
a59	ls.asm	/^ a59:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a5a	grep.asm	/^ a5a:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a5a	sh.asm	/^     a5a:	89 04 24             	mov    %eax,(%esp)$/;"	l
a5c	ls.asm	/^ a5c:	8b 00                	mov    (%eax),%eax$/;"	l
a5d	grep.asm	/^ a5d:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a5d	sh.asm	/^     a5d:	e8 1c fd ff ff       	call   77e <parseline>$/;"	l
a5e	ls.asm	/^ a5e:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a6	cat.asm	/^  a6:	89 04 24             	mov    %eax,(%esp)$/;"	l
a6	grep.asm	/^  a6:	ba 20 0e 00 00       	mov    $0xe20,%edx$/;"	l
a6	mkdir.asm	/^  a6:	5f                   	pop    %edi$/;"	l
a6	rm.asm	/^  a6:	5f                   	pop    %edi$/;"	l
a60	grep.asm	/^ a60:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a61	ls.asm	/^ a61:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a62	sh.asm	/^     a62:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
a63	grep.asm	/^ a63:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a64	ls.asm	/^ a64:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a65	sh.asm	/^     a65:	c7 44 24 08 4c 15 00 	movl   $0x154c,0x8(%esp)$/;"	l
a66	grep.asm	/^ a66:	72 4d                	jb     ab5 <malloc+0xa6>$/;"	l
a67	ls.asm	/^ a67:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a68	grep.asm	/^ a68:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a6a	ls.asm	/^ a6a:	72 4d                	jb     ab9 <malloc+0xa6>$/;"	l
a6b	grep.asm	/^ a6b:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a6c	ls.asm	/^ a6c:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a6c	sh.asm	/^     a6c:	00 $/;"	l
a6d	sh.asm	/^     a6d:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
a6e	grep.asm	/^ a6e:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a6f	ls.asm	/^ a6f:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a7	kill.asm	/^  a7:	84 c0                	test   %al,%al$/;"	l
a7	ln.asm	/^  a7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a7	mkdir.asm	/^  a7:	5d                   	pop    %ebp$/;"	l
a7	rm.asm	/^  a7:	5d                   	pop    %ebp$/;"	l
a7	sh.asm	/^      a7:	e8 f4 0e 00 00       	call   fa0 <open>$/;"	l
a7	zombie.asm	/^  a7:	0f b6 00             	movzbl (%eax),%eax$/;"	l
a70	sh.asm	/^     a70:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
a71	grep.asm	/^ a71:	75 0c                	jne    a7f <malloc+0x70>$/;"	l
a72	ls.asm	/^ a72:	3b 45 ec             	cmp    -0x14(%ebp),%eax$/;"	l
a73	grep.asm	/^ a73:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a74	sh.asm	/^     a74:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
a75	ls.asm	/^ a75:	75 0c                	jne    a83 <malloc+0x70>$/;"	l
a76	grep.asm	/^ a76:	8b 10                	mov    (%eax),%edx$/;"	l
a77	ls.asm	/^ a77:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a77	sh.asm	/^     a77:	89 04 24             	mov    %eax,(%esp)$/;"	l
a78	grep.asm	/^ a78:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a7a	ls.asm	/^ a7a:	8b 10                	mov    (%eax),%edx$/;"	l
a7a	sh.asm	/^     a7a:	e8 fe fb ff ff       	call   67d <peek>$/;"	l
a7b	grep.asm	/^ a7b:	89 10                	mov    %edx,(%eax)$/;"	l
a7c	ls.asm	/^ a7c:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
a7d	grep.asm	/^ a7d:	eb 26                	jmp    aa5 <malloc+0x96>$/;"	l
a7f	grep.asm	/^ a7f:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a7f	ls.asm	/^ a7f:	89 10                	mov    %edx,(%eax)$/;"	l
a7f	sh.asm	/^     a7f:	85 c0                	test   %eax,%eax$/;"	l
a8	echo.asm	/^  a8:	0f b6 00             	movzbl (%eax),%eax$/;"	l
a8	ls.asm	/^  a8:	83 c4 24             	add    $0x24,%esp$/;"	l
a8	mkdir.asm	/^  a8:	c3                   	ret    $/;"	l
a8	rm.asm	/^  a8:	c3                   	ret    $/;"	l
a8	wc.asm	/^  a8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)$/;"	l
a81	ls.asm	/^ a81:	eb 26                	jmp    aa9 <malloc+0x96>$/;"	l
a81	sh.asm	/^     a81:	75 0c                	jne    a8f <parseblock+0x91>$/;"	l
a82	grep.asm	/^ a82:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a83	ls.asm	/^ a83:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a83	sh.asm	/^     a83:	c7 04 24 4e 15 00 00 	movl   $0x154e,(%esp)$/;"	l
a85	grep.asm	/^ a85:	89 c2                	mov    %eax,%edx$/;"	l
a86	ls.asm	/^ a86:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a87	grep.asm	/^ a87:	2b 55 ec             	sub    -0x14(%ebp),%edx$/;"	l
a89	ls.asm	/^ a89:	89 c2                	mov    %eax,%edx$/;"	l
a8a	grep.asm	/^ a8a:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a8a	sh.asm	/^     a8a:	e8 cb f8 ff ff       	call   35a <panic>$/;"	l
a8b	ls.asm	/^ a8b:	2b 55 ec             	sub    -0x14(%ebp),%edx$/;"	l
a8d	grep.asm	/^ a8d:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a8e	ls.asm	/^ a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a8f	sh.asm	/^     a8f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)$/;"	l
a9	cat.asm	/^  a9:	e8 06 03 00 00       	call   3b4 <open>$/;"	l
a9	init.asm	/^  a9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)$/;"	l
a9	kill.asm	/^  a9:	0f 95 c0             	setne  %al$/;"	l
a9	mkdir.asm	/^  a9:	55                   	push   %ebp$/;"	l
a9	rm.asm	/^  a9:	55                   	push   %ebp$/;"	l
a90	grep.asm	/^ a90:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a91	ls.asm	/^ a91:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
a93	grep.asm	/^ a93:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a94	ls.asm	/^ a94:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a96	grep.asm	/^ a96:	c1 e0 03             	shl    $0x3,%eax$/;"	l
a96	sh.asm	/^     a96:	00 $/;"	l
a97	ls.asm	/^ a97:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
a97	sh.asm	/^     a97:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)$/;"	l
a99	grep.asm	/^ a99:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
a9a	ls.asm	/^ a9a:	c1 e0 03             	shl    $0x3,%eax$/;"	l
a9c	grep.asm	/^ a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
a9d	ls.asm	/^ a9d:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
a9e	sh.asm	/^     a9e:	00 $/;"	l
a9f	grep.asm	/^ a9f:	8b 55 ec             	mov    -0x14(%ebp),%edx$/;"	l
a9f	sh.asm	/^     a9f:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
aa	ln.asm	/^  aa:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
aa	mkdir.asm	/^  aa:	89 e5                	mov    %esp,%ebp$/;"	l
aa	rm.asm	/^  aa:	89 e5                	mov    %esp,%ebp$/;"	l
aa	zombie.asm	/^  aa:	0f b6 d0             	movzbl %al,%edx$/;"	l
aa0	ls.asm	/^ aa0:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
aa2	grep.asm	/^ aa2:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
aa2	sh.asm	/^     aa2:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
aa3	ls.asm	/^ aa3:	8b 55 ec             	mov    -0x14(%ebp),%edx$/;"	l
aa5	grep.asm	/^ aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
aa6	ls.asm	/^ aa6:	89 50 04             	mov    %edx,0x4(%eax)$/;"	l
aa6	sh.asm	/^     aa6:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
aa8	grep.asm	/^ aa8:	a3 08 0e 00 00       	mov    %eax,0xe08$/;"	l
aa9	ls.asm	/^ aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
aa9	sh.asm	/^     aa9:	89 04 24             	mov    %eax,(%esp)$/;"	l
aac	ls.asm	/^ aac:	a3 00 0e 00 00       	mov    %eax,0xe00$/;"	l
aac	sh.asm	/^     aac:	e8 84 fa ff ff       	call   535 <gettoken>$/;"	l
aad	grep.asm	/^ aad:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ab	echo.asm	/^  ab:	84 c0                	test   %al,%al$/;"	l
ab	grep.asm	/^  ab:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ab	ls.asm	/^  ab:	5b                   	pop    %ebx$/;"	l
ab0	grep.asm	/^ ab0:	83 c0 08             	add    $0x8,%eax$/;"	l
ab1	ls.asm	/^ ab1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ab1	sh.asm	/^     ab1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ab3	grep.asm	/^ ab3:	eb 38                	jmp    aed <malloc+0xde>$/;"	l
ab4	ls.asm	/^ ab4:	83 c0 08             	add    $0x8,%eax$/;"	l
ab4	sh.asm	/^     ab4:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ab5	grep.asm	/^ ab5:	a1 08 0e 00 00       	mov    0xe08,%eax$/;"	l
ab7	ls.asm	/^ ab7:	eb 38                	jmp    af1 <malloc+0xde>$/;"	l
ab8	sh.asm	/^     ab8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ab9	ls.asm	/^ ab9:	a1 00 0e 00 00       	mov    0xe00,%eax$/;"	l
aba	grep.asm	/^ aba:	39 45 f4             	cmp    %eax,-0xc(%ebp)$/;"	l
abb	sh.asm	/^     abb:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
abd	grep.asm	/^ abd:	75 1b                	jne    ada <malloc+0xcb>$/;"	l
abe	ls.asm	/^ abe:	39 45 f4             	cmp    %eax,-0xc(%ebp)$/;"	l
abf	grep.asm	/^ abf:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
abf	sh.asm	/^     abf:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ac	kill.asm	/^  ac:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
ac	ls.asm	/^  ac:	5d                   	pop    %ebp$/;"	l
ac	mkdir.asm	/^  ac:	83 ec 10             	sub    $0x10,%esp$/;"	l
ac	rm.asm	/^  ac:	83 ec 10             	sub    $0x10,%esp$/;"	l
ac	sh.asm	/^      ac:	85 c0                	test   %eax,%eax$/;"	l
ac	wc.asm	/^  ac:	0f 8f 70 ff ff ff    	jg     22 <wc+0x22>$/;"	l
ac1	ls.asm	/^ ac1:	75 1b                	jne    ade <malloc+0xcb>$/;"	l
ac2	grep.asm	/^ ac2:	89 04 24             	mov    %eax,(%esp)$/;"	l
ac2	sh.asm	/^     ac2:	89 04 24             	mov    %eax,(%esp)$/;"	l
ac3	ls.asm	/^ ac3:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
ac5	grep.asm	/^ ac5:	e8 ed fe ff ff       	call   9b7 <morecore>$/;"	l
ac5	sh.asm	/^     ac5:	e8 0c fe ff ff       	call   8d6 <parseredirs>$/;"	l
ac6	ls.asm	/^ ac6:	89 04 24             	mov    %eax,(%esp)$/;"	l
ac9	ls.asm	/^ ac9:	e8 ed fe ff ff       	call   9bb <morecore>$/;"	l
aca	grep.asm	/^ aca:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
aca	sh.asm	/^     aca:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
acd	grep.asm	/^ acd:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
acd	sh.asm	/^     acd:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ace	ls.asm	/^ ace:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
acquire	spinlock.c	/^acquire(struct spinlock *lk)$/;"	f
ad	echo.asm	/^  ad:	0f 95 c0             	setne  %al$/;"	l
ad	ln.asm	/^  ad:	90                   	nop$/;"	l
ad	ls.asm	/^  ad:	c3                   	ret    $/;"	l
ad	zombie.asm	/^  ad:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ad0	sh.asm	/^     ad0:	c9                   	leave  $/;"	l
ad1	grep.asm	/^ ad1:	75 07                	jne    ada <malloc+0xcb>$/;"	l
ad1	ls.asm	/^ ad1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
ad1	sh.asm	/^     ad1:	c3                   	ret    $/;"	l
ad2	sh.asm	/^     ad2:	55                   	push   %ebp$/;"	l
ad3	grep.asm	/^ ad3:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
ad3	sh.asm	/^     ad3:	89 e5                	mov    %esp,%ebp$/;"	l
ad5	ls.asm	/^ ad5:	75 07                	jne    ade <malloc+0xcb>$/;"	l
ad5	sh.asm	/^     ad5:	83 ec 38             	sub    $0x38,%esp$/;"	l
ad7	ls.asm	/^ ad7:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
ad8	grep.asm	/^ ad8:	eb 13                	jmp    aed <malloc+0xde>$/;"	l
ad8	sh.asm	/^     ad8:	c7 44 24 08 3f 15 00 	movl   $0x153f,0x8(%esp)$/;"	l
ada	grep.asm	/^ ada:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
adc	ls.asm	/^ adc:	eb 13                	jmp    af1 <malloc+0xde>$/;"	l
add	grep.asm	/^ add:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
addr	kernel.asm	/^  addr = p2v(a);$/;"	d
addr	kernel.asm	/^  addr = proc->sz;$/;"	d
addr	mp.h	/^  uint *addr;                  \/\/ I\/O APIC address$/;"	m	struct:mpioapic
addrs	file.h	/^  uint addrs[NDIRECT+1];$/;"	m	struct:inode
addrs	fs.h	/^  uint addrs[NDIRECT+1];   \/\/ Data block addresses$/;"	m	struct:dinode
ade	ls.asm	/^ ade:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
adf	sh.asm	/^     adf:	00 $/;"	l
ae	cat.asm	/^  ae:	89 44 24 18          	mov    %eax,0x18(%esp)$/;"	l
ae	grep.asm	/^  ae:	89 d1                	mov    %edx,%ecx$/;"	l
ae	init.asm	/^  ae:	75 41                	jne    f1 <main+0xf1>$/;"	l
ae	ln.asm	/^  ae:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ae	ls.asm	/^  ae:	55                   	push   %ebp$/;"	l
ae	sh.asm	/^      ae:	79 23                	jns    d3 <runcmd+0xd3>$/;"	l
ae0	grep.asm	/^ ae0:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ae0	sh.asm	/^     ae0:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ae1	ls.asm	/^ ae1:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
ae3	grep.asm	/^ ae3:	8b 00                	mov    (%eax),%eax$/;"	l
ae3	sh.asm	/^     ae3:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
ae4	ls.asm	/^ ae4:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ae5	grep.asm	/^ ae5:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
ae7	ls.asm	/^ ae7:	8b 00                	mov    (%eax),%eax$/;"	l
ae7	sh.asm	/^     ae7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ae8	grep.asm	/^ ae8:	e9 70 ff ff ff       	jmp    a5d <malloc+0x4e>$/;"	l
ae9	ls.asm	/^ ae9:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
aea	sh.asm	/^     aea:	89 04 24             	mov    %eax,(%esp)$/;"	l
aec	ls.asm	/^ aec:	e9 70 ff ff ff       	jmp    a61 <malloc+0x4e>$/;"	l
aed	grep.asm	/^ aed:	c9                   	leave  $/;"	l
aed	sh.asm	/^     aed:	e8 8b fb ff ff       	call   67d <peek>$/;"	l
aee	grep.asm	/^ aee:	c3                   	ret    $/;"	l
af	ls.asm	/^  af:	89 e5                	mov    %esp,%ebp$/;"	l
af	mkdir.asm	/^  af:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
af	rm.asm	/^  af:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
af1	ls.asm	/^ af1:	c9                   	leave  $/;"	l
af2	ls.asm	/^ af2:	c3                   	ret    $/;"	l
af2	sh.asm	/^     af2:	85 c0                	test   %eax,%eax$/;"	l
af4	sh.asm	/^     af4:	74 17                	je     b0d <parseexec+0x3b>$/;"	l
af6	sh.asm	/^     af6:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
af9	sh.asm	/^     af9:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
afd	sh.asm	/^     afd:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
align	elf.h	/^  uint align;$/;"	m	struct:proghdr
allocproc	proc.c	/^allocproc(void)$/;"	f	file:
allocuvm	vm.c	/^allocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
alltraps	kernel.asm	/^alltraps:$/;"	l
alltraps	trapasm.S	/^alltraps:$/;"	l
ap	cat.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	echo.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	grep.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	init.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	kill.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ln.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	ls.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	mkdir.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	rm.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	sh.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	wc.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
ap	zombie.asm	/^  ap = (uint*)(void*)&fmt + 1;$/;"	d
apicid	mp.h	/^  uchar apicid;                 \/\/ local APIC id$/;"	m	struct:mpproc
apicno	mp.h	/^  uchar apicno;                 \/\/ I\/O APIC id$/;"	m	struct:mpioapic
argc	sh.asm	/^  argc = 0;$/;"	d
argfd	sysfile.c	/^argfd(int n, int *pfd, struct file **pf)$/;"	f	file:
argint	syscall.c	/^argint(int n, int *ip)$/;"	f
argp	kernel.asm	/^  argp = (uint*)(void*)(&fmt + 1);$/;"	d
argptr	syscall.c	/^argptr(int n, char **pp, int size)$/;"	f
args	mmu.h	/^  uint args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:gatedesc
argstr	syscall.c	/^argstr(int n, char **pp)$/;"	f
argv	init.c	/^char *argv[] = { "sh", 0 };$/;"	v
argv	initcode.S	/^argv:$/;"	l
argv	sh.c	/^  char *argv[MAXARGS];$/;"	m	struct:execcmd	file:
atoi	ulib.c	/^atoi(const char *s)$/;"	f
avl	mmu.h	/^  uint avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:segdesc
b	cat.asm	/^   b:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b	kernel.asm	/^  b = bget(dev, sector);$/;"	d
b0	echo.asm	/^  b0:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
b0	grep.asm	/^  b0:	29 c1                	sub    %eax,%ecx$/;"	l
b0	init.asm	/^  b0:	c7 44 24 04 48 0b 00 	movl   $0xb48,0x4(%esp)$/;"	l
b0	kill.asm	/^  b0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
b0	sh.asm	/^      b0:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
b0	zombie.asm	/^  b0:	0f b6 00             	movzbl (%eax),%eax$/;"	l
b00	sh.asm	/^     b00:	89 04 24             	mov    %eax,(%esp)$/;"	l
b03	sh.asm	/^     b03:	e8 f6 fe ff ff       	call   9fe <parseblock>$/;"	l
b08	sh.asm	/^     b08:	e9 0b 01 00 00       	jmp    c18 <parseexec+0x146>$/;"	l
b0d	sh.asm	/^     b0d:	e8 93 f8 ff ff       	call   3a5 <execcmd>$/;"	l
b1	ln.asm	/^  b1:	0f b6 10             	movzbl (%eax),%edx$/;"	l
b1	ls.asm	/^  b1:	57                   	push   %edi$/;"	l
b12	sh.asm	/^     b12:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
b15	sh.asm	/^     b15:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
b18	sh.asm	/^     b18:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
b1b	sh.asm	/^     b1b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)$/;"	l
b2	cat.asm	/^  b2:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)$/;"	l
b2	grep.asm	/^  b2:	89 c8                	mov    %ecx,%eax$/;"	l
b2	ls.asm	/^  b2:	56                   	push   %esi$/;"	l
b2	mkdir.asm	/^  b2:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
b2	rm.asm	/^  b2:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
b2	wc.asm	/^  b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)$/;"	l
b22	sh.asm	/^     b22:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b25	sh.asm	/^     b25:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b29	sh.asm	/^     b29:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b2c	sh.asm	/^     b2c:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
b3	ls.asm	/^  b3:	53                   	push   %ebx$/;"	l
b3	sh.asm	/^      b3:	8b 40 08             	mov    0x8(%eax),%eax$/;"	l
b3	zombie.asm	/^  b3:	0f b6 c0             	movzbl %al,%eax$/;"	l
b30	sh.asm	/^     b30:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
b33	sh.asm	/^     b33:	89 04 24             	mov    %eax,(%esp)$/;"	l
b36	sh.asm	/^     b36:	e8 9b fd ff ff       	call   8d6 <parseredirs>$/;"	l
b3b	sh.asm	/^     b3b:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
b3e	sh.asm	/^     b3e:	e9 8e 00 00 00       	jmp    bd1 <parseexec+0xff>$/;"	l
b4	echo.asm	/^  b4:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
b4	grep.asm	/^  b4:	01 45 f4             	add    %eax,-0xc(%ebp)$/;"	l
b4	kill.asm	/^  b4:	84 c0                	test   %al,%al$/;"	l
b4	ln.asm	/^  b4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b4	ls.asm	/^  b4:	81 ec 5c 02 00 00    	sub    $0x25c,%esp$/;"	l
b43	sh.asm	/^     b43:	8d 45 e0             	lea    -0x20(%ebp),%eax$/;"	l
b46	sh.asm	/^     b46:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
b4a	sh.asm	/^     b4a:	8d 45 e4             	lea    -0x1c(%ebp),%eax$/;"	l
b4d	sh.asm	/^     b4d:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b5	mkdir.asm	/^  b5:	90                   	nop$/;"	l
b5	rm.asm	/^  b5:	90                   	nop$/;"	l
b51	sh.asm	/^     b51:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b54	sh.asm	/^     b54:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
b58	sh.asm	/^     b58:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b5b	sh.asm	/^     b5b:	89 04 24             	mov    %eax,(%esp)$/;"	l
b5e	sh.asm	/^     b5e:	e8 d2 f9 ff ff       	call   535 <gettoken>$/;"	l
b6	kill.asm	/^  b6:	75 de                	jne    96 <strcpy+0xd>$/;"	l
b6	mkdir.asm	/^  b6:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b6	rm.asm	/^  b6:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
b6	sh.asm	/^      b6:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
b6	wc.asm	/^  b6:	79 19                	jns    d1 <wc+0xd1>$/;"	l
b6	zombie.asm	/^  b6:	89 d1                	mov    %edx,%ecx$/;"	l
b63	sh.asm	/^     b63:	89 45 e8             	mov    %eax,-0x18(%ebp)$/;"	l
b66	sh.asm	/^     b66:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)$/;"	l
b6a	sh.asm	/^     b6a:	0f 84 85 00 00 00    	je     bf5 <parseexec+0x123>$/;"	l
b7	cat.asm	/^  b7:	79 29                	jns    e2 <main+0x7a>$/;"	l
b7	grep.asm	/^  b7:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
b7	init.asm	/^  b7:	00 $/;"	l
b7	ln.asm	/^  b7:	88 10                	mov    %dl,(%eax)$/;"	l
b70	sh.asm	/^     b70:	83 7d e8 61          	cmpl   $0x61,-0x18(%ebp)$/;"	l
b74	sh.asm	/^     b74:	74 0c                	je     b82 <parseexec+0xb0>$/;"	l
b76	sh.asm	/^     b76:	c7 04 24 12 15 00 00 	movl   $0x1512,(%esp)$/;"	l
b7d	sh.asm	/^     b7d:	e8 d8 f7 ff ff       	call   35a <panic>$/;"	l
b8	echo.asm	/^  b8:	84 c0                	test   %al,%al$/;"	l
b8	init.asm	/^  b8:	c7 04 24 b3 08 00 00 	movl   $0x8b3,(%esp)$/;"	l
b8	kill.asm	/^  b8:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
b8	wc.asm	/^  b8:	c7 44 24 04 69 09 00 	movl   $0x969,0x4(%esp)$/;"	l
b8	zombie.asm	/^  b8:	29 c1                	sub    %eax,%ecx$/;"	l
b82	sh.asm	/^     b82:	8b 4d e4             	mov    -0x1c(%ebp),%ecx$/;"	l
b85	sh.asm	/^     b85:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
b88	sh.asm	/^     b88:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
b8b	sh.asm	/^     b8b:	89 4c 90 04          	mov    %ecx,0x4(%eax,%edx,4)$/;"	l
b8f	sh.asm	/^     b8f:	8b 55 e0             	mov    -0x20(%ebp),%edx$/;"	l
b9	cat.asm	/^  b9:	8b 44 24 1c          	mov    0x1c(%esp),%eax$/;"	l
b9	ln.asm	/^  b9:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
b9	mkdir.asm	/^  b9:	0f b6 10             	movzbl (%eax),%edx$/;"	l
b9	rm.asm	/^  b9:	0f b6 10             	movzbl (%eax),%edx$/;"	l
b92	sh.asm	/^     b92:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
b95	sh.asm	/^     b95:	8b 4d f4             	mov    -0xc(%ebp),%ecx$/;"	l
b98	sh.asm	/^     b98:	83 c1 08             	add    $0x8,%ecx$/;"	l
b9b	sh.asm	/^     b9b:	89 54 88 0c          	mov    %edx,0xc(%eax,%ecx,4)$/;"	l
b9f	sh.asm	/^     b9f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)$/;"	l
ba	echo.asm	/^  ba:	75 de                	jne    9a <strcpy+0xd>$/;"	l
ba	grep.asm	/^  ba:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ba	ls.asm	/^  ba:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
ba	sh.asm	/^      ba:	c7 44 24 04 b3 14 00 	movl   $0x14b3,0x4(%esp)$/;"	l
ba	zombie.asm	/^  ba:	89 c8                	mov    %ecx,%eax$/;"	l
ba3	sh.asm	/^     ba3:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)$/;"	l
ba7	sh.asm	/^     ba7:	7e 0c                	jle    bb5 <parseexec+0xe3>$/;"	l
ba9	sh.asm	/^     ba9:	c7 04 24 61 15 00 00 	movl   $0x1561,(%esp)$/;"	l
backcmd	sh.c	/^backcmd(struct cmd *subcmd)$/;"	f
backcmd	sh.c	/^struct backcmd {$/;"	s	file:
bad	kernel.asm	/^ bad:$/;"	l
bad	kernel.asm	/^bad:$/;"	l
balloc	fs.c	/^balloc(uint dev)$/;"	f	file:
balloc	mkfs.c	/^balloc(int used)$/;"	f
base	umalloc.c	/^static Header base;$/;"	v	file:
base_15_0	mmu.h	/^  uint base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:segdesc
base_23_16	mmu.h	/^  uint base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:segdesc
base_31_24	mmu.h	/^  uint base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:segdesc
bb	kill.asm	/^  bb:	c9                   	leave  $/;"	l
bb0	sh.asm	/^     bb0:	e8 a5 f7 ff ff       	call   35a <panic>$/;"	l
bb5	sh.asm	/^     bb5:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
bb8	sh.asm	/^     bb8:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
bbc	sh.asm	/^     bbc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
bbf	sh.asm	/^     bbf:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
bc	echo.asm	/^  bc:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
bc	kill.asm	/^  bc:	c3                   	ret    $/;"	l
bc	ln.asm	/^  bc:	0f b6 00             	movzbl (%eax),%eax$/;"	l
bc	mkdir.asm	/^  bc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
bc	rm.asm	/^  bc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
bc	zombie.asm	/^  bc:	5d                   	pop    %ebp$/;"	l
bc3	sh.asm	/^     bc3:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
bc6	sh.asm	/^     bc6:	89 04 24             	mov    %eax,(%esp)$/;"	l
bc9	sh.asm	/^     bc9:	e8 08 fd ff ff       	call   8d6 <parseredirs>$/;"	l
bcache	bio.c	/^} bcache;$/;"	v	typeref:struct:__anon1
bce	sh.asm	/^     bce:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
bcmd	sh.asm	/^    bcmd = (struct backcmd*)cmd;$/;"	d
bcpu	kernel.asm	/^        bcpu = &cpus[ncpu];$/;"	d
bcpu	kernel.asm	/^  bcpu = &cpus[0];$/;"	d
bcpu	mp.c	/^static struct cpu *bcpu;$/;"	v	typeref:struct:cpu	file:
bd	cat.asm	/^  bd:	c1 e0 02             	shl    $0x2,%eax$/;"	l
bd	kill.asm	/^  bd:	55                   	push   %ebp$/;"	l
bd	zombie.asm	/^  bd:	c3                   	ret    $/;"	l
bd1	sh.asm	/^     bd1:	c7 44 24 08 6f 15 00 	movl   $0x156f,0x8(%esp)$/;"	l
bd8	sh.asm	/^     bd8:	00 $/;"	l
bd9	sh.asm	/^     bd9:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
bda	kernel.asm	/^  bda = (uchar *) P2V(0x400);$/;"	d
bdc	sh.asm	/^     bdc:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
be	grep.asm	/^  be:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
be	kill.asm	/^  be:	89 e5                	mov    %esp,%ebp$/;"	l
be	zombie.asm	/^  be:	55                   	push   %ebp$/;"	l
be0	sh.asm	/^     be0:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
be3	sh.asm	/^     be3:	89 04 24             	mov    %eax,(%esp)$/;"	l
be6	sh.asm	/^     be6:	e8 92 fa ff ff       	call   67d <peek>$/;"	l
beb	sh.asm	/^     beb:	85 c0                	test   %eax,%eax$/;"	l
bed	sh.asm	/^     bed:	0f 84 50 ff ff ff    	je     b43 <parseexec+0x71>$/;"	l
begin_trans	log.c	/^begin_trans(void)$/;"	f
bf	echo.asm	/^  bf:	c9                   	leave  $/;"	l
bf	init.asm	/^  bf:	e8 ec 02 00 00       	call   3b0 <exec>$/;"	l
bf	ln.asm	/^  bf:	84 c0                	test   %al,%al$/;"	l
bf	mkdir.asm	/^  bf:	88 10                	mov    %dl,(%eax)$/;"	l
bf	rm.asm	/^  bf:	88 10                	mov    %dl,(%eax)$/;"	l
bf	wc.asm	/^  bf:	00 $/;"	l
bf	zombie.asm	/^  bf:	89 e5                	mov    %esp,%ebp$/;"	l
bf3	sh.asm	/^     bf3:	eb 01                	jmp    bf6 <parseexec+0x124>$/;"	l
bf5	sh.asm	/^     bf5:	90                   	nop$/;"	l
bf6	sh.asm	/^     bf6:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
bf9	sh.asm	/^     bf9:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
bfc	sh.asm	/^     bfc:	c7 44 90 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,4)$/;"	l
bfree	fs.c	/^bfree(int dev, uint b)$/;"	f	file:
bget	bio.c	/^bget(uint dev, uint sector)$/;"	f	file:
bi	kernel.asm	/^  bi = b % BPB;$/;"	d
binit	bio.c	/^binit(void)$/;"	f
bitblocks	mkfs.c	/^uint bitblocks;$/;"	v
bmap	fs.c	/^bmap(struct inode *ip, uint bn)$/;"	f	file:
bootmain	bootmain.c	/^bootmain(void)$/;"	f
bp	cat.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	echo.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	grep.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	init.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	kernel.asm	/^    bp = bread(dev, BBLOCK(b, sb.ninodes));$/;"	d
bp	kernel.asm	/^    bp = bread(dev, IBLOCK(inum));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, IBLOCK(ip->inum));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, addr);$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, bmap(ip, off\/BSIZE));$/;"	d
bp	kernel.asm	/^    bp = bread(ip->dev, ip->addrs[NDIRECT]);$/;"	d
bp	kernel.asm	/^  bp = 0;$/;"	d
bp	kernel.asm	/^  bp = bread(dev, 1);$/;"	d
bp	kernel.asm	/^  bp = bread(dev, BBLOCK(b, sb.ninodes));$/;"	d
bp	kernel.asm	/^  bp = bread(dev, bno);$/;"	d
bp	kernel.asm	/^  bp = bread(ip->dev, IBLOCK(ip->inum));$/;"	d
bp	kill.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ln.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	ls.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	mkdir.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	rm.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	sh.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	wc.asm	/^  bp = (Header*)ap - 1;$/;"	d
bp	zombie.asm	/^  bp = (Header*)ap - 1;$/;"	d
bread	bio.c	/^bread(uint dev, uint sector)$/;"	f
brelse	bio.c	/^brelse(struct buf *b)$/;"	f
buf	bio.c	/^  struct buf buf[NBUF];$/;"	m	struct:__anon1	typeref:struct:__anon1::buf	file:
buf	buf.h	/^struct buf {$/;"	s
buf	cat.c	/^char buf[512];$/;"	v
buf	console.c	/^  char buf[INPUT_BUF];$/;"	m	struct:__anon3	file:
buf	grep.c	/^char buf[1024];$/;"	v
buf	kernel.asm	/^  buf = (char*)p;$/;"	d
buf	wc.c	/^char buf[512];$/;"	v
busy	log.c	/^  int busy; \/\/ a transaction is active$/;"	m	struct:log	file:
bwrite	bio.c	/^bwrite(struct buf *b)$/;"	f
bzero	fs.c	/^bzero(int dev, int bno)$/;"	f	file:
c	cat.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	echo.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	grep.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	init.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	initcode.asm	/^   c:	b8 07 00 00 00       	mov    $0x7,%eax$/;"	l
c	kernel.asm	/^        c = (c == '\\r') ? '\\n' : c;$/;"	d
c	kernel.asm	/^    c = fmt[++i] & 0xff;$/;"	d
c	kernel.asm	/^    c = input.buf[input.r++ % INPUT_BUF];$/;"	d
c	kernel.asm	/^  c = &cpus[cpunum()];$/;"	d
c	kernel.asm	/^  c = charcode[shift & (CTL | SHIFT)][data];$/;"	d
c	kill.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ln.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	ls.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	mkdir.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	rm.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	sh.asm	/^       c:	e8 4f 0f 00 00       	call   f60 <exit>$/;"	l
c	sh.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	wc.asm	/^    c = fmt[i] & 0xff;$/;"	d
c	zombie.asm	/^    c = fmt[i] & 0xff;$/;"	d
c0	cat.asm	/^  c0:	03 45 0c             	add    0xc(%ebp),%eax$/;"	l
c0	echo.asm	/^  c0:	c3                   	ret    $/;"	l
c0	kill.asm	/^  c0:	eb 08                	jmp    ca <strcmp+0xd>$/;"	l
c0	wc.asm	/^  c0:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
c03	sh.asm	/^     c03:	00 $/;"	l
c04	sh.asm	/^     c04:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
c07	sh.asm	/^     c07:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
c0a	sh.asm	/^     c0a:	83 c2 08             	add    $0x8,%edx$/;"	l
c0d	sh.asm	/^     c0d:	c7 44 90 0c 00 00 00 	movl   $0x0,0xc(%eax,%edx,4)$/;"	l
c1	echo.asm	/^  c1:	55                   	push   %ebp$/;"	l
c1	grep.asm	/^  c1:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
c1	ln.asm	/^  c1:	0f 95 c0             	setne  %al$/;"	l
c1	ls.asm	/^  c1:	00 $/;"	l
c1	mkdir.asm	/^  c1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c1	rm.asm	/^  c1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c1	sh.asm	/^      c1:	00 $/;"	l
c1	zombie.asm	/^  c1:	83 ec 10             	sub    $0x10,%esp$/;"	l
c14	sh.asm	/^     c14:	00 $/;"	l
c15	sh.asm	/^     c15:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
c18	sh.asm	/^     c18:	c9                   	leave  $/;"	l
c19	sh.asm	/^     c19:	c3                   	ret    $/;"	l
c1a	sh.asm	/^     c1a:	55                   	push   %ebp$/;"	l
c1b	sh.asm	/^     c1b:	89 e5                	mov    %esp,%ebp$/;"	l
c1d	sh.asm	/^     c1d:	83 ec 38             	sub    $0x38,%esp$/;"	l
c2	echo.asm	/^  c2:	89 e5                	mov    %esp,%ebp$/;"	l
c2	kill.asm	/^  c2:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c2	ls.asm	/^  c2:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c2	sh.asm	/^      c2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)$/;"	l
c20	sh.asm	/^     c20:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)$/;"	l
c24	sh.asm	/^     c24:	75 0a                	jne    c30 <nulterminate+0x16>$/;"	l
c26	sh.asm	/^     c26:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
c2b	sh.asm	/^     c2b:	e9 c9 00 00 00       	jmp    cf9 <nulterminate+0xdf>$/;"	l
c3	cat.asm	/^  c3:	8b 00                	mov    (%eax),%eax$/;"	l
c30	sh.asm	/^     c30:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c33	sh.asm	/^     c33:	8b 00                	mov    (%eax),%eax$/;"	l
c35	sh.asm	/^     c35:	83 f8 05             	cmp    $0x5,%eax$/;"	l
c38	sh.asm	/^     c38:	0f 87 b8 00 00 00    	ja     cf6 <nulterminate+0xdc>$/;"	l
c3e	sh.asm	/^     c3e:	8b 04 85 74 15 00 00 	mov    0x1574(,%eax,4),%eax$/;"	l
c4	echo.asm	/^  c4:	eb 08                	jmp    ce <strcmp+0xd>$/;"	l
c4	init.asm	/^  c4:	c7 44 24 04 e4 08 00 	movl   $0x8e4,0x4(%esp)$/;"	l
c4	ln.asm	/^  c4:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c4	mkdir.asm	/^  c4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
c4	rm.asm	/^  c4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
c4	zombie.asm	/^  c4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)$/;"	l
c45	sh.asm	/^     c45:	ff e0                	jmp    *%eax$/;"	l
c47	sh.asm	/^     c47:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c4a	sh.asm	/^     c4a:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
c4d	sh.asm	/^     c4d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)$/;"	l
c5	cat.asm	/^  c5:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
c5	grep.asm	/^  c5:	c7 04 24 20 0e 00 00 	movl   $0xe20,(%esp)$/;"	l
c5	ls.asm	/^  c5:	89 04 24             	mov    %eax,(%esp)$/;"	l
c54	sh.asm	/^     c54:	eb 14                	jmp    c6a <nulterminate+0x50>$/;"	l
c56	sh.asm	/^     c56:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
c59	sh.asm	/^     c59:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
c5c	sh.asm	/^     c5c:	83 c2 08             	add    $0x8,%edx$/;"	l
c5f	sh.asm	/^     c5f:	8b 44 90 0c          	mov    0xc(%eax,%edx,4),%eax$/;"	l
c6	echo.asm	/^  c6:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
c6	kill.asm	/^  c6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
c63	sh.asm	/^     c63:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
c66	sh.asm	/^     c66:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)$/;"	l
c6a	sh.asm	/^     c6a:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
c6d	sh.asm	/^     c6d:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
c7	mkdir.asm	/^  c7:	84 c0                	test   %al,%al$/;"	l
c7	rm.asm	/^  c7:	84 c0                	test   %al,%al$/;"	l
c7	wc.asm	/^  c7:	e8 d3 04 00 00       	call   59f <printf>$/;"	l
c70	sh.asm	/^     c70:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax$/;"	l
c74	sh.asm	/^     c74:	85 c0                	test   %eax,%eax$/;"	l
c76	sh.asm	/^     c76:	75 de                	jne    c56 <nulterminate+0x3c>$/;"	l
c78	sh.asm	/^     c78:	eb 7c                	jmp    cf6 <nulterminate+0xdc>$/;"	l
c7a	sh.asm	/^     c7a:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c7d	sh.asm	/^     c7d:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
c8	ln.asm	/^  c8:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
c8	ls.asm	/^  c8:	e8 2b 05 00 00       	call   5f8 <open>$/;"	l
c80	sh.asm	/^     c80:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
c83	sh.asm	/^     c83:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
c86	sh.asm	/^     c86:	89 04 24             	mov    %eax,(%esp)$/;"	l
c89	sh.asm	/^     c89:	e8 8c ff ff ff       	call   c1a <nulterminate>$/;"	l
c8e	sh.asm	/^     c8e:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
c9	cat.asm	/^  c9:	c7 44 24 04 c0 08 00 	movl   $0x8c0,0x4(%esp)$/;"	l
c9	mkdir.asm	/^  c9:	0f 95 c0             	setne  %al$/;"	l
c9	rm.asm	/^  c9:	0f 95 c0             	setne  %al$/;"	l
c9	sh.asm	/^      c9:	e8 09 10 00 00       	call   10d7 <printf>$/;"	l
c91	sh.asm	/^     c91:	8b 40 0c             	mov    0xc(%eax),%eax$/;"	l
c94	sh.asm	/^     c94:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
c97	sh.asm	/^     c97:	eb 5d                	jmp    cf6 <nulterminate+0xdc>$/;"	l
c99	sh.asm	/^     c99:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
c9c	sh.asm	/^     c9c:	89 45 e8             	mov    %eax,-0x18(%ebp)$/;"	l
c9f	sh.asm	/^     c9f:	8b 45 e8             	mov    -0x18(%ebp),%eax$/;"	l
ca	echo.asm	/^  ca:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
ca	kill.asm	/^  ca:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ca2	sh.asm	/^     ca2:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ca5	sh.asm	/^     ca5:	89 04 24             	mov    %eax,(%esp)$/;"	l
ca8	sh.asm	/^     ca8:	e8 6d ff ff ff       	call   c1a <nulterminate>$/;"	l
cad	sh.asm	/^     cad:	8b 45 e8             	mov    -0x18(%ebp),%eax$/;"	l
cat	cat.c	/^cat(int fd)$/;"	f
cb	init.asm	/^  cb:	00 $/;"	l
cb	zombie.asm	/^  cb:	eb 04                	jmp    d1 <strlen+0x13>$/;"	l
cb0	sh.asm	/^     cb0:	8b 40 08             	mov    0x8(%eax),%eax$/;"	l
cb3	sh.asm	/^     cb3:	89 04 24             	mov    %eax,(%esp)$/;"	l
cb6	sh.asm	/^     cb6:	e8 5f ff ff ff       	call   c1a <nulterminate>$/;"	l
cbb	sh.asm	/^     cbb:	eb 39                	jmp    cf6 <nulterminate+0xdc>$/;"	l
cbd	sh.asm	/^     cbd:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
cc	cat.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	echo.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	grep.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	grep.asm	/^  cc:	e8 9d 04 00 00       	call   56e <memmove>$/;"	l
cc	init.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	init.asm	/^  cc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
cc	kill.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	ln.asm	/^  cc:	84 c0                	test   %al,%al$/;"	l
cc	ls.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	mkdir.asm	/^  cc:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
cc	rm.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	rm.asm	/^  cc:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
cc	sh.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	wc.asm	/^    cc = read(0, &c, 1);$/;"	d
cc	wc.asm	/^  cc:	e8 57 03 00 00       	call   428 <exit>$/;"	l
cc	zombie.asm	/^    cc = read(0, &c, 1);$/;"	d
cc0	sh.asm	/^     cc0:	89 45 e4             	mov    %eax,-0x1c(%ebp)$/;"	l
cc3	sh.asm	/^     cc3:	8b 45 e4             	mov    -0x1c(%ebp),%eax$/;"	l
cc6	sh.asm	/^     cc6:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
cc9	sh.asm	/^     cc9:	89 04 24             	mov    %eax,(%esp)$/;"	l
ccc	sh.asm	/^     ccc:	e8 49 ff ff ff       	call   c1a <nulterminate>$/;"	l
cd	kill.asm	/^  cd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
cd	ls.asm	/^  cd:	89 45 e4             	mov    %eax,-0x1c(%ebp)$/;"	l
cd	zombie.asm	/^  cd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)$/;"	l
cd1	sh.asm	/^     cd1:	8b 45 e4             	mov    -0x1c(%ebp),%eax$/;"	l
cd4	sh.asm	/^     cd4:	8b 40 08             	mov    0x8(%eax),%eax$/;"	l
cd7	sh.asm	/^     cd7:	89 04 24             	mov    %eax,(%esp)$/;"	l
cda	sh.asm	/^     cda:	e8 3b ff ff ff       	call   c1a <nulterminate>$/;"	l
cdf	sh.asm	/^     cdf:	eb 15                	jmp    cf6 <nulterminate+0xdc>$/;"	l
ce	echo.asm	/^  ce:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ce	ln.asm	/^  ce:	75 de                	jne    ae <strcpy+0xd>$/;"	l
ce	sh.asm	/^      ce:	e8 8d 0e 00 00       	call   f60 <exit>$/;"	l
ce1	sh.asm	/^     ce1:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ce4	sh.asm	/^     ce4:	89 45 e0             	mov    %eax,-0x20(%ebp)$/;"	l
ce7	sh.asm	/^     ce7:	8b 45 e0             	mov    -0x20(%ebp),%eax$/;"	l
cea	sh.asm	/^     cea:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
ced	sh.asm	/^     ced:	89 04 24             	mov    %eax,(%esp)$/;"	l
cf0	sh.asm	/^     cf0:	e8 25 ff ff ff       	call   c1a <nulterminate>$/;"	l
cf5	sh.asm	/^     cf5:	90                   	nop$/;"	l
cf6	sh.asm	/^     cf6:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
cf9	sh.asm	/^     cf9:	c9                   	leave  $/;"	l
cfa	sh.asm	/^     cfa:	c3                   	ret    $/;"	l
cfb	sh.asm	/^     cfb:	90                   	nop$/;"	l
cfc	sh.asm	/^     cfc:	55                   	push   %ebp$/;"	l
cfd	sh.asm	/^     cfd:	89 e5                	mov    %esp,%ebp$/;"	l
cff	sh.asm	/^     cff:	57                   	push   %edi$/;"	l
cgaputc	console.c	/^cgaputc(int c)$/;"	f	file:
chan	proc.h	/^  void *chan;                  \/\/ If non-zero, sleeping on chan$/;"	m	struct:proc
char	cat.asm	/^char buf[512];$/;"	l
char	grep.asm	/^char buf[1024];$/;"	l
char	init.asm	/^char *argv[] = { "sh", 0 };$/;"	l
char	sh.asm	/^char symbols[] = "<|>&;()";$/;"	l
char	sh.asm	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	l
char	wc.asm	/^char buf[512];$/;"	l
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mp
checksum	mp.h	/^  uchar checksum;               \/\/ all bytes must add up to 0$/;"	m	struct:mpconf
clearpteu	vm.c	/^clearpteu(pde_t *pgdir, char *uva)$/;"	f
cli	x86.h	/^cli(void)$/;"	f
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_RDONLY, 0);$/;"	d
cmd	sh.asm	/^      cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);$/;"	d
cmd	sh.asm	/^    cmd = backcmd(cmd);$/;"	d
cmd	sh.asm	/^    cmd = listcmd(cmd, parseline(ps, es));$/;"	d
cmd	sh.asm	/^    cmd = pipecmd(cmd, parsepipe(ps, es));$/;"	d
cmd	sh.asm	/^  cmd = (struct execcmd*)ret;$/;"	d
cmd	sh.asm	/^  cmd = malloc(sizeof(*cmd));$/;"	d
cmd	sh.asm	/^  cmd = parseexec(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(&s, es);$/;"	d
cmd	sh.asm	/^  cmd = parseline(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parsepipe(ps, es);$/;"	d
cmd	sh.asm	/^  cmd = parseredirs(cmd, ps, es);$/;"	d
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:backcmd	typeref:struct:backcmd::cmd	file:
cmd	sh.c	/^  struct cmd *cmd;$/;"	m	struct:redircmd	typeref:struct:redircmd::cmd	file:
cmd	sh.c	/^struct cmd {$/;"	s	file:
code	kernel.asm	/^  code = p2v(0x7000);$/;"	d
commit_trans	log.c	/^commit_trans(void)$/;"	f
conf	kernel.asm	/^  conf = (struct mpconf*) p2v((uint) mp->physaddr);$/;"	d
cons	console.c	/^} cons;$/;"	v	typeref:struct:__anon2	file:
consoleinit	console.c	/^consoleinit(void)$/;"	f
consoleintr	console.c	/^consoleintr(int (*getc)(void))$/;"	f
consoleread	console.c	/^consoleread(struct inode *ip, char *dst, int n)$/;"	f
consolewrite	console.c	/^consolewrite(struct inode *ip, char *buf, int n)$/;"	f
consputc	console.c	/^consputc(int c)$/;"	f
context	proc.h	/^  struct context *context;     \/\/ swtch() here to run process$/;"	m	struct:proc	typeref:struct:proc::context
context	proc.h	/^struct context {$/;"	s
copyout	vm.c	/^copyout(pde_t *pgdir, uint va, void *p, uint len)$/;"	f
copyuvm	vm.c	/^copyuvm(pde_t *pgdir, uint sz)$/;"	f
cprintf	console.c	/^cprintf(char *fmt, ...)$/;"	f
cpu	kernel.asm	/^  cpu = c;$/;"	d
cpu	proc.h	/^  struct cpu *cpu;$/;"	m	struct:cpu	typeref:struct:cpu::cpu
cpu	proc.h	/^struct cpu {$/;"	s
cpu	spinlock.h	/^  struct cpu *cpu;   \/\/ The cpu holding the lock.$/;"	m	struct:spinlock	typeref:struct:spinlock::cpu
cpunum	lapic.c	/^cpunum(void)$/;"	f
cpus	mp.c	/^struct cpu cpus[NCPU];$/;"	v	typeref:struct:cpu
cr3	mmu.h	/^  void *cr3;         \/\/ Page directory base$/;"	m	struct:taskstate
create	sysfile.c	/^create(char *path, short type, short major, short minor)$/;"	f	file:
crt	console.c	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	v	file:
cs	mmu.h	/^  uint cs : 16;         \/\/ code segment selector$/;"	m	struct:gatedesc
cs	mmu.h	/^  ushort cs;$/;"	m	struct:taskstate
cs	x86.h	/^  ushort cs;$/;"	m	struct:trapframe
ctlmap	kbd.h	/^static uchar ctlmap[256] =$/;"	v
cwd	proc.h	/^  struct inode *cwd;           \/\/ Current directory$/;"	m	struct:proc	typeref:struct:proc::inode
d	grep.asm	/^   d:	e9 bf 00 00 00       	jmp    d1 <grep+0xd1>$/;"	l
d	kernel.asm	/^  d = dst;$/;"	d
d	kill.asm	/^   d:	7f 19                	jg     28 <main+0x28>$/;"	l
d	ln.asm	/^   d:	74 19                	je     28 <main+0x28>$/;"	l
d	ls.asm	/^   d:	e8 dc 03 00 00       	call   3ee <strlen>$/;"	l
d	mkdir.asm	/^   d:	7f 19                	jg     28 <main+0x28>$/;"	l
d	rm.asm	/^   d:	7f 19                	jg     28 <main+0x28>$/;"	l
d	wc.asm	/^   d:	8b 45 e8             	mov    -0x18(%ebp),%eax$/;"	l
d0	cat.asm	/^  d0:	00 $/;"	l
d0	kill.asm	/^  d0:	84 c0                	test   %al,%al$/;"	l
d0	ln.asm	/^  d0:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d0	ls.asm	/^  d0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)$/;"	l
d0	mkdir.asm	/^  d0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
d0	rm.asm	/^  d0:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
d00	sh.asm	/^     d00:	53                   	push   %ebx$/;"	l
d01	sh.asm	/^     d01:	8b 4d 08             	mov    0x8(%ebp),%ecx$/;"	l
d04	sh.asm	/^     d04:	8b 55 10             	mov    0x10(%ebp),%edx$/;"	l
d07	sh.asm	/^     d07:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d0a	sh.asm	/^     d0a:	89 cb                	mov    %ecx,%ebx$/;"	l
d0c	sh.asm	/^     d0c:	89 df                	mov    %ebx,%edi$/;"	l
d0e	sh.asm	/^     d0e:	89 d1                	mov    %edx,%ecx$/;"	l
d1	cat.asm	/^  d1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
d1	echo.asm	/^  d1:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d1	grep.asm	/^  d1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
d1	wc.asm	/^  d1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d1	zombie.asm	/^  d1:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d10	sh.asm	/^     d10:	fc                   	cld    $/;"	l
d11	sh.asm	/^     d11:	f3 aa                	rep stos %al,%es:(%edi)$/;"	l
d13	sh.asm	/^     d13:	89 ca                	mov    %ecx,%edx$/;"	l
d15	sh.asm	/^     d15:	89 fb                	mov    %edi,%ebx$/;"	l
d17	sh.asm	/^     d17:	89 5d 08             	mov    %ebx,0x8(%ebp)$/;"	l
d1a	sh.asm	/^     d1a:	89 55 10             	mov    %edx,0x10(%ebp)$/;"	l
d1d	sh.asm	/^     d1d:	5b                   	pop    %ebx$/;"	l
d1e	sh.asm	/^     d1e:	5f                   	pop    %edi$/;"	l
d1f	sh.asm	/^     d1f:	5d                   	pop    %ebp$/;"	l
d2	kill.asm	/^  d2:	74 10                	je     e4 <strcmp+0x27>$/;"	l
d20	sh.asm	/^     d20:	c3                   	ret    $/;"	l
d21	sh.asm	/^     d21:	55                   	push   %ebp$/;"	l
d22	sh.asm	/^     d22:	89 e5                	mov    %esp,%ebp$/;"	l
d24	sh.asm	/^     d24:	83 ec 10             	sub    $0x10,%esp$/;"	l
d27	sh.asm	/^     d27:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d2a	sh.asm	/^     d2a:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
d2d	sh.asm	/^     d2d:	90                   	nop$/;"	l
d2e	sh.asm	/^     d2e:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d3	init.asm	/^  d3:	e8 17 04 00 00       	call   4ef <printf>$/;"	l
d3	ln.asm	/^  d3:	c9                   	leave  $/;"	l
d3	sh.asm	/^      d3:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
d31	sh.asm	/^     d31:	0f b6 10             	movzbl (%eax),%edx$/;"	l
d34	sh.asm	/^     d34:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d37	sh.asm	/^     d37:	88 10                	mov    %dl,(%eax)$/;"	l
d39	sh.asm	/^     d39:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d3c	sh.asm	/^     d3c:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d3f	sh.asm	/^     d3f:	84 c0                	test   %al,%al$/;"	l
d4	echo.asm	/^  d4:	84 c0                	test   %al,%al$/;"	l
d4	grep.asm	/^  d4:	ba 00 04 00 00       	mov    $0x400,%edx$/;"	l
d4	kill.asm	/^  d4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d4	ln.asm	/^  d4:	c3                   	ret    $/;"	l
d4	ls.asm	/^  d4:	79 20                	jns    f6 <ls+0x48>$/;"	l
d4	mkdir.asm	/^  d4:	84 c0                	test   %al,%al$/;"	l
d4	rm.asm	/^  d4:	84 c0                	test   %al,%al$/;"	l
d4	wc.asm	/^  d4:	89 44 24 14          	mov    %eax,0x14(%esp)$/;"	l
d4	zombie.asm	/^  d4:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
d41	sh.asm	/^     d41:	0f 95 c0             	setne  %al$/;"	l
d44	sh.asm	/^     d44:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
d48	sh.asm	/^     d48:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
d4c	sh.asm	/^     d4c:	84 c0                	test   %al,%al$/;"	l
d4e	sh.asm	/^     d4e:	75 de                	jne    d2e <strcpy+0xd>$/;"	l
d5	ln.asm	/^  d5:	55                   	push   %ebp$/;"	l
d50	sh.asm	/^     d50:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d53	sh.asm	/^     d53:	c9                   	leave  $/;"	l
d54	sh.asm	/^     d54:	c3                   	ret    $/;"	l
d55	sh.asm	/^     d55:	55                   	push   %ebp$/;"	l
d56	sh.asm	/^     d56:	89 e5                	mov    %esp,%ebp$/;"	l
d58	sh.asm	/^     d58:	eb 08                	jmp    d62 <strcmp+0xd>$/;"	l
d5a	sh.asm	/^     d5a:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
d5e	sh.asm	/^     d5e:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
d6	echo.asm	/^  d6:	74 10                	je     e8 <strcmp+0x27>$/;"	l
d6	ln.asm	/^  d6:	89 e5                	mov    %esp,%ebp$/;"	l
d6	ls.asm	/^  d6:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d6	mkdir.asm	/^  d6:	75 de                	jne    b6 <strcpy+0xd>$/;"	l
d6	rm.asm	/^  d6:	75 de                	jne    b6 <strcpy+0xd>$/;"	l
d6	sh.asm	/^      d6:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
d62	sh.asm	/^     d62:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d65	sh.asm	/^     d65:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d68	sh.asm	/^     d68:	84 c0                	test   %al,%al$/;"	l
d6a	sh.asm	/^     d6a:	74 10                	je     d7c <strcmp+0x27>$/;"	l
d6c	sh.asm	/^     d6c:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d6f	sh.asm	/^     d6f:	0f b6 10             	movzbl (%eax),%edx$/;"	l
d7	kill.asm	/^  d7:	0f b6 10             	movzbl (%eax),%edx$/;"	l
d7	zombie.asm	/^  d7:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d72	sh.asm	/^     d72:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d75	sh.asm	/^     d75:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d78	sh.asm	/^     d78:	38 c2                	cmp    %al,%dl$/;"	l
d7a	sh.asm	/^     d7a:	74 de                	je     d5a <strcmp+0x5>$/;"	l
d7c	sh.asm	/^     d7c:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d7f	sh.asm	/^     d7f:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d8	cat.asm	/^  d8:	e8 0e 04 00 00       	call   4eb <printf>$/;"	l
d8	echo.asm	/^  d8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
d8	init.asm	/^  d8:	e8 9b 02 00 00       	call   378 <exit>$/;"	l
d8	ln.asm	/^  d8:	eb 08                	jmp    e2 <strcmp+0xd>$/;"	l
d8	mkdir.asm	/^  d8:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d8	rm.asm	/^  d8:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
d8	wc.asm	/^  d8:	8b 45 e8             	mov    -0x18(%ebp),%eax$/;"	l
d82	sh.asm	/^     d82:	0f b6 d0             	movzbl %al,%edx$/;"	l
d85	sh.asm	/^     d85:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
d88	sh.asm	/^     d88:	0f b6 00             	movzbl (%eax),%eax$/;"	l
d8b	sh.asm	/^     d8b:	0f b6 c0             	movzbl %al,%eax$/;"	l
d8e	sh.asm	/^     d8e:	89 d1                	mov    %edx,%ecx$/;"	l
d9	grep.asm	/^  d9:	89 d1                	mov    %edx,%ecx$/;"	l
d9	ls.asm	/^  d9:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
d9	sh.asm	/^      d9:	89 04 24             	mov    %eax,(%esp)$/;"	l
d90	sh.asm	/^     d90:	29 c1                	sub    %eax,%ecx$/;"	l
d92	sh.asm	/^     d92:	89 c8                	mov    %ecx,%eax$/;"	l
d94	sh.asm	/^     d94:	5d                   	pop    %ebp$/;"	l
d95	sh.asm	/^     d95:	c3                   	ret    $/;"	l
d96	sh.asm	/^     d96:	55                   	push   %ebp$/;"	l
d97	sh.asm	/^     d97:	89 e5                	mov    %esp,%ebp$/;"	l
d99	sh.asm	/^     d99:	83 ec 10             	sub    $0x10,%esp$/;"	l
d9c	sh.asm	/^     d9c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)$/;"	l
da	kill.asm	/^  da:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
da	ln.asm	/^  da:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
da	zombie.asm	/^  da:	84 c0                	test   %al,%al$/;"	l
da3	sh.asm	/^     da3:	eb 04                	jmp    da9 <strlen+0x13>$/;"	l
da5	sh.asm	/^     da5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)$/;"	l
da9	sh.asm	/^     da9:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
dac	sh.asm	/^     dac:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
daf	sh.asm	/^     daf:	0f b6 00             	movzbl (%eax),%eax$/;"	l
data	buf.h	/^  uchar data[512];$/;"	m	struct:buf
data	ioapic.c	/^  uint data;$/;"	m	struct:ioapic	file:
data	kernel.asm	/^    data = (shift & E0ESC ? data : data & 0x7F);$/;"	d
data	kernel.asm	/^  data = inb(KBDATAP);$/;"	d
data	pipe.c	/^  char data[PIPESIZE];$/;"	m	struct:pipe	file:
db	echo.asm	/^  db:	0f b6 10             	movzbl (%eax),%edx$/;"	l
db	grep.asm	/^  db:	29 c1                	sub    %eax,%ecx$/;"	l
db	mkdir.asm	/^  db:	c9                   	leave  $/;"	l
db	mmu.h	/^  uint db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:segdesc
db	rm.asm	/^  db:	c9                   	leave  $/;"	l
db	wc.asm	/^  db:	89 44 24 10          	mov    %eax,0x10(%esp)$/;"	l
db2	sh.asm	/^     db2:	84 c0                	test   %al,%al$/;"	l
db4	sh.asm	/^     db4:	75 ef                	jne    da5 <strlen+0xf>$/;"	l
db6	sh.asm	/^     db6:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
db9	sh.asm	/^     db9:	c9                   	leave  $/;"	l
dba	sh.asm	/^     dba:	c3                   	ret    $/;"	l
dbb	sh.asm	/^     dbb:	55                   	push   %ebp$/;"	l
dbc	sh.asm	/^     dbc:	89 e5                	mov    %esp,%ebp$/;"	l
dbe	sh.asm	/^     dbe:	83 ec 0c             	sub    $0xc,%esp$/;"	l
dc	mkdir.asm	/^  dc:	c3                   	ret    $/;"	l
dc	rm.asm	/^  dc:	c3                   	ret    $/;"	l
dc	sh.asm	/^      dc:	e8 1f ff ff ff       	call   0 <runcmd>$/;"	l
dc	zombie.asm	/^  dc:	75 ef                	jne    cd <strlen+0xf>$/;"	l
dc1	sh.asm	/^     dc1:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
dc4	sh.asm	/^     dc4:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
dc8	sh.asm	/^     dc8:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
dcb	sh.asm	/^     dcb:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
dcf	sh.asm	/^     dcf:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
dd	cat.asm	/^  dd:	e8 92 02 00 00       	call   374 <exit>$/;"	l
dd	grep.asm	/^  dd:	89 c8                	mov    %ecx,%eax$/;"	l
dd	init.asm	/^  dd:	c7 44 24 04 fa 08 00 	movl   $0x8fa,0x4(%esp)$/;"	l
dd	kill.asm	/^  dd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
dd	ls.asm	/^  dd:	c7 44 24 04 f3 0a 00 	movl   $0xaf3,0x4(%esp)$/;"	l
dd	mkdir.asm	/^  dd:	55                   	push   %ebp$/;"	l
dd	rm.asm	/^  dd:	55                   	push   %ebp$/;"	l
dd2	sh.asm	/^     dd2:	89 04 24             	mov    %eax,(%esp)$/;"	l
dd5	sh.asm	/^     dd5:	e8 22 ff ff ff       	call   cfc <stosb>$/;"	l
dda	sh.asm	/^     dda:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ddd	sh.asm	/^     ddd:	c9                   	leave  $/;"	l
dde	sh.asm	/^     dde:	c3                   	ret    $/;"	l
ddf	sh.asm	/^     ddf:	55                   	push   %ebp$/;"	l
de	echo.asm	/^  de:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
de	ln.asm	/^  de:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
de	mkdir.asm	/^  de:	89 e5                	mov    %esp,%ebp$/;"	l
de	rm.asm	/^  de:	89 e5                	mov    %esp,%ebp$/;"	l
de	zombie.asm	/^  de:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
de0	sh.asm	/^     de0:	89 e5                	mov    %esp,%ebp$/;"	l
de2	sh.asm	/^     de2:	83 ec 04             	sub    $0x4,%esp$/;"	l
de5	sh.asm	/^     de5:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
de8	sh.asm	/^     de8:	88 45 fc             	mov    %al,-0x4(%ebp)$/;"	l
deallocuvm	vm.c	/^deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)$/;"	f
deb	sh.asm	/^     deb:	eb 14                	jmp    e01 <strchr+0x22>$/;"	l
ded	sh.asm	/^     ded:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
default	kernel.asm	/^    default:$/;"	l
default	kernel.asm	/^  default:$/;"	l
default	sh.asm	/^  default:$/;"	l
dev	buf.h	/^  uint dev;$/;"	m	struct:buf
dev	file.h	/^  uint dev;           \/\/ Device number$/;"	m	struct:inode
dev	log.c	/^  int dev;$/;"	m	struct:log	file:
dev	stat.h	/^  int dev;     \/\/ Device number$/;"	m	struct:stat
devsw	file.c	/^struct devsw devsw[NDEV];$/;"	v	typeref:struct:devsw
devsw	file.h	/^struct devsw {$/;"	s
df	grep.asm	/^  df:	8b 55 f4             	mov    -0xc(%ebp),%edx$/;"	l
df	wc.asm	/^  df:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
df0	sh.asm	/^     df0:	0f b6 00             	movzbl (%eax),%eax$/;"	l
df3	sh.asm	/^     df3:	3a 45 fc             	cmp    -0x4(%ebp),%al$/;"	l
df6	sh.asm	/^     df6:	75 05                	jne    dfd <strchr+0x1e>$/;"	l
df8	sh.asm	/^     df8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
dfb	sh.asm	/^     dfb:	eb 13                	jmp    e10 <strchr+0x31>$/;"	l
dfd	sh.asm	/^     dfd:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
dinode	fs.h	/^struct dinode {$/;"	s
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + inum%IPB;$/;"	d
dip	kernel.asm	/^    dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dip	kernel.asm	/^  dip = (struct dinode*)bp->data + ip->inum%IPB;$/;"	d
dirent	fs.h	/^struct dirent {$/;"	s
dirlink	fs.c	/^dirlink(struct inode *dp, char *name, uint inum)$/;"	f
dirlookup	fs.c	/^dirlookup(struct inode *dp, char *name, uint *poff)$/;"	f
disksize	memide.c	/^static int disksize;$/;"	v	file:
dpl	mmu.h	/^  uint dpl : 2;         \/\/ descriptor(meaning new) privilege level$/;"	m	struct:gatedesc
dpl	mmu.h	/^  uint dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:segdesc
ds	mmu.h	/^  ushort ds;$/;"	m	struct:taskstate
ds	x86.h	/^  ushort ds;$/;"	m	struct:trapframe
dst	cat.asm	/^  dst = vdst;$/;"	d
dst	echo.asm	/^  dst = vdst;$/;"	d
dst	grep.asm	/^  dst = vdst;$/;"	d
dst	init.asm	/^  dst = vdst;$/;"	d
dst	kill.asm	/^  dst = vdst;$/;"	d
dst	ln.asm	/^  dst = vdst;$/;"	d
dst	ls.asm	/^  dst = vdst;$/;"	d
dst	mkdir.asm	/^  dst = vdst;$/;"	d
dst	rm.asm	/^  dst = vdst;$/;"	d
dst	sh.asm	/^  dst = vdst;$/;"	d
dst	wc.asm	/^  dst = vdst;$/;"	d
dst	zombie.asm	/^  dst = vdst;$/;"	d
e	console.c	/^  uint e;  \/\/ Edit index$/;"	m	struct:__anon3	file:
e	kernel.asm	/^  e = addr+len;$/;"	d
e	zombie.asm	/^   e:	85 c0                	test   %eax,%eax$/;"	l
e0	kill.asm	/^  e0:	38 c2                	cmp    %al,%dl$/;"	l
e0	mkdir.asm	/^  e0:	eb 08                	jmp    ea <strcmp+0xd>$/;"	l
e0	rm.asm	/^  e0:	eb 08                	jmp    ea <strcmp+0xd>$/;"	l
e01	sh.asm	/^     e01:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e04	sh.asm	/^     e04:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e07	sh.asm	/^     e07:	84 c0                	test   %al,%al$/;"	l
e09	sh.asm	/^     e09:	75 e2                	jne    ded <strchr+0xe>$/;"	l
e0b	sh.asm	/^     e0b:	b8 00 00 00 00       	mov    $0x0,%eax$/;"	l
e1	echo.asm	/^  e1:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e1	sh.asm	/^      e1:	e9 1e 01 00 00       	jmp    204 <runcmd+0x204>$/;"	l
e1	zombie.asm	/^  e1:	c9                   	leave  $/;"	l
e10	sh.asm	/^     e10:	c9                   	leave  $/;"	l
e11	sh.asm	/^     e11:	c3                   	ret    $/;"	l
e12	sh.asm	/^     e12:	55                   	push   %ebp$/;"	l
e13	sh.asm	/^     e13:	89 e5                	mov    %esp,%ebp$/;"	l
e15	sh.asm	/^     e15:	83 ec 28             	sub    $0x28,%esp$/;"	l
e18	sh.asm	/^     e18:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)$/;"	l
e1f	sh.asm	/^     e1f:	eb 44                	jmp    e65 <gets+0x53>$/;"	l
e2	cat.asm	/^  e2:	8b 44 24 18          	mov    0x18(%esp),%eax$/;"	l
e2	grep.asm	/^  e2:	81 c2 20 0e 00 00    	add    $0xe20,%edx$/;"	l
e2	kill.asm	/^  e2:	74 de                	je     c2 <strcmp+0x5>$/;"	l
e2	ln.asm	/^  e2:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e2	mkdir.asm	/^  e2:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
e2	rm.asm	/^  e2:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
e2	wc.asm	/^  e2:	89 44 24 0c          	mov    %eax,0xc(%esp)$/;"	l
e2	zombie.asm	/^  e2:	c3                   	ret    $/;"	l
e21	sh.asm	/^     e21:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)$/;"	l
e28	sh.asm	/^     e28:	00 $/;"	l
e29	sh.asm	/^     e29:	8d 45 ef             	lea    -0x11(%ebp),%eax$/;"	l
e2c	sh.asm	/^     e2c:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
e3	zombie.asm	/^  e3:	55                   	push   %ebp$/;"	l
e30	sh.asm	/^     e30:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)$/;"	l
e37	sh.asm	/^     e37:	e8 3c 01 00 00       	call   f78 <read>$/;"	l
e3c	sh.asm	/^     e3c:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
e3f	sh.asm	/^     e3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)$/;"	l
e4	echo.asm	/^  e4:	38 c2                	cmp    %al,%dl$/;"	l
e4	init.asm	/^  e4:	00 $/;"	l
e4	kill.asm	/^  e4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e4	ls.asm	/^  e4:	00 $/;"	l
e4	zombie.asm	/^  e4:	89 e5                	mov    %esp,%ebp$/;"	l
e43	sh.asm	/^     e43:	7e 2d                	jle    e72 <gets+0x60>$/;"	l
e45	sh.asm	/^     e45:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e48	sh.asm	/^     e48:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
e4b	sh.asm	/^     e4b:	0f b6 55 ef          	movzbl -0x11(%ebp),%edx$/;"	l
e4f	sh.asm	/^     e4f:	88 10                	mov    %dl,(%eax)$/;"	l
e5	init.asm	/^  e5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
e5	ln.asm	/^  e5:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e5	ls.asm	/^  e5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)$/;"	l
e51	sh.asm	/^     e51:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)$/;"	l
e55	sh.asm	/^     e55:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax$/;"	l
e59	sh.asm	/^     e59:	3c 0a                	cmp    $0xa,%al$/;"	l
e5b	sh.asm	/^     e5b:	74 16                	je     e73 <gets+0x61>$/;"	l
e5d	sh.asm	/^     e5d:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax$/;"	l
e6	cat.asm	/^  e6:	89 04 24             	mov    %eax,(%esp)$/;"	l
e6	echo.asm	/^  e6:	74 de                	je     c6 <strcmp+0x5>$/;"	l
e6	mkdir.asm	/^  e6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
e6	rm.asm	/^  e6:	83 45 0c 01          	addl   $0x1,0xc(%ebp)$/;"	l
e6	sh.asm	/^      e6:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e6	wc.asm	/^  e6:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
e6	zombie.asm	/^  e6:	83 ec 0c             	sub    $0xc,%esp$/;"	l
e61	sh.asm	/^     e61:	3c 0d                	cmp    $0xd,%al$/;"	l
e63	sh.asm	/^     e63:	74 0e                	je     e73 <gets+0x61>$/;"	l
e65	sh.asm	/^     e65:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e68	sh.asm	/^     e68:	83 c0 01             	add    $0x1,%eax$/;"	l
e6b	sh.asm	/^     e6b:	3b 45 0c             	cmp    0xc(%ebp),%eax$/;"	l
e6e	sh.asm	/^     e6e:	7c b1                	jl     e21 <gets+0xf>$/;"	l
e7	kill.asm	/^  e7:	0f b6 00             	movzbl (%eax),%eax$/;"	l
e70	sh.asm	/^     e70:	eb 01                	jmp    e73 <gets+0x61>$/;"	l
e72	sh.asm	/^     e72:	90                   	nop$/;"	l
e73	sh.asm	/^     e73:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
e76	sh.asm	/^     e76:	03 45 08             	add    0x8(%ebp),%eax$/;"	l
e79	sh.asm	/^     e79:	c6 00 00             	movb   $0x0,(%eax)$/;"	l
e7c	sh.asm	/^     e7c:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e7f	sh.asm	/^     e7f:	c9                   	leave  $/;"	l
e8	echo.asm	/^  e8:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e8	grep.asm	/^  e8:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
e8	ln.asm	/^  e8:	84 c0                	test   %al,%al$/;"	l
e80	sh.asm	/^     e80:	c3                   	ret    $/;"	l
e81	sh.asm	/^     e81:	55                   	push   %ebp$/;"	l
e82	sh.asm	/^     e82:	89 e5                	mov    %esp,%ebp$/;"	l
e84	sh.asm	/^     e84:	83 ec 28             	sub    $0x28,%esp$/;"	l
e87	sh.asm	/^     e87:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)$/;"	l
e8e	sh.asm	/^     e8e:	00 $/;"	l
e8f	sh.asm	/^     e8f:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
e9	cat.asm	/^  e9:	e8 12 ff ff ff       	call   0 <cat>$/;"	l
e9	sh.asm	/^      e9:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
e9	wc.asm	/^  e9:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
e9	zombie.asm	/^  e9:	8b 45 10             	mov    0x10(%ebp),%eax$/;"	l
e92	sh.asm	/^     e92:	89 04 24             	mov    %eax,(%esp)$/;"	l
e95	sh.asm	/^     e95:	e8 06 01 00 00       	call   fa0 <open>$/;"	l
e9a	sh.asm	/^     e9a:	89 45 f4             	mov    %eax,-0xc(%ebp)$/;"	l
e9d	sh.asm	/^     e9d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)$/;"	l
ea	kill.asm	/^  ea:	0f b6 d0             	movzbl %al,%edx$/;"	l
ea	ln.asm	/^  ea:	74 10                	je     fc <strcmp+0x27>$/;"	l
ea	mkdir.asm	/^  ea:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ea	rm.asm	/^  ea:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ea1	sh.asm	/^     ea1:	79 07                	jns    eaa <stat+0x29>$/;"	l
ea3	sh.asm	/^     ea3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax$/;"	l
ea8	sh.asm	/^     ea8:	eb 23                	jmp    ecd <stat+0x4c>$/;"	l
eaa	sh.asm	/^     eaa:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ead	sh.asm	/^     ead:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
eargv	sh.c	/^  char *eargv[MAXARGS];$/;"	m	struct:execcmd	file:
eax	mmu.h	/^  uint eax;          \/\/ More saved state (registers)$/;"	m	struct:taskstate
eax	x86.h	/^  uint eax;$/;"	m	struct:trapframe
eb	echo.asm	/^  eb:	0f b6 00             	movzbl (%eax),%eax$/;"	l
eb1	sh.asm	/^     eb1:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
eb4	sh.asm	/^     eb4:	89 04 24             	mov    %eax,(%esp)$/;"	l
eb7	sh.asm	/^     eb7:	e8 fc 00 00 00       	call   fb8 <fstat>$/;"	l
ebc	sh.asm	/^     ebc:	89 45 f0             	mov    %eax,-0x10(%ebp)$/;"	l
ebf	sh.asm	/^     ebf:	8b 45 f4             	mov    -0xc(%ebp),%eax$/;"	l
ebp	kernel.asm	/^    ebp = (uint*)ebp[0]; \/\/ saved %ebp$/;"	d
ebp	kernel.asm	/^  ebp = (uint*)v - 2;$/;"	d
ebp	mmu.h	/^  uint *ebp;$/;"	m	struct:taskstate
ebp	proc.h	/^  uint ebp;$/;"	m	struct:context
ebp	uthread.h	/^	int 	       	ebp;        \/* current base pointer *\/$/;"	m	struct:uthread
ebp	x86.h	/^  uint ebp;$/;"	m	struct:trapframe
ebx	mmu.h	/^  uint ebx;$/;"	m	struct:taskstate
ebx	proc.h	/^  uint ebx;$/;"	m	struct:context
ebx	x86.h	/^  uint ebx;$/;"	m	struct:trapframe
ec	grep.asm	/^  ec:	89 54 24 04          	mov    %edx,0x4(%esp)$/;"	l
ec	init.asm	/^  ec:	e8 fe 03 00 00       	call   4ef <printf>$/;"	l
ec	ln.asm	/^  ec:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
ec	ls.asm	/^  ec:	e8 3e 06 00 00       	call   72f <printf>$/;"	l
ec	sh.asm	/^      ec:	e8 8f 02 00 00       	call   380 <fork1>$/;"	l
ec	zombie.asm	/^  ec:	89 44 24 08          	mov    %eax,0x8(%esp)$/;"	l
ec2	sh.asm	/^     ec2:	89 04 24             	mov    %eax,(%esp)$/;"	l
ec5	sh.asm	/^     ec5:	e8 be 00 00 00       	call   f88 <close>$/;"	l
eca	sh.asm	/^     eca:	8b 45 f0             	mov    -0x10(%ebp),%eax$/;"	l
ecd	sh.asm	/^     ecd:	c9                   	leave  $/;"	l
ece	sh.asm	/^     ece:	c3                   	ret    $/;"	l
ecf	sh.asm	/^     ecf:	55                   	push   %ebp$/;"	l
ecmd	sh.asm	/^    ecmd = (struct execcmd*)cmd;$/;"	d
ecx	mmu.h	/^  uint ecx;$/;"	m	struct:taskstate
ecx	x86.h	/^  uint ecx;$/;"	m	struct:trapframe
ed	kill.asm	/^  ed:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
ed	mkdir.asm	/^  ed:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ed	rm.asm	/^  ed:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ed	wc.asm	/^  ed:	c7 44 24 04 79 09 00 	movl   $0x979,0x4(%esp)$/;"	l
ed0	sh.asm	/^     ed0:	89 e5                	mov    %esp,%ebp$/;"	l
ed2	sh.asm	/^     ed2:	83 ec 10             	sub    $0x10,%esp$/;"	l
ed5	sh.asm	/^     ed5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)$/;"	l
edc	sh.asm	/^     edc:	eb 23                	jmp    f01 <atoi+0x32>$/;"	l
ede	sh.asm	/^     ede:	8b 55 fc             	mov    -0x4(%ebp),%edx$/;"	l
edi	mmu.h	/^  uint edi;$/;"	m	struct:taskstate
edi	proc.h	/^  uint edi;$/;"	m	struct:context
edi	x86.h	/^  uint edi;$/;"	m	struct:trapframe
edx	mmu.h	/^  uint edx;$/;"	m	struct:taskstate
edx	x86.h	/^  uint edx;$/;"	m	struct:trapframe
ee	cat.asm	/^  ee:	8b 44 24 18          	mov    0x18(%esp),%eax$/;"	l
ee	echo.asm	/^  ee:	0f b6 d0             	movzbl %al,%edx$/;"	l
ee1	sh.asm	/^     ee1:	89 d0                	mov    %edx,%eax$/;"	l
ee3	sh.asm	/^     ee3:	c1 e0 02             	shl    $0x2,%eax$/;"	l
ee6	sh.asm	/^     ee6:	01 d0                	add    %edx,%eax$/;"	l
ee8	sh.asm	/^     ee8:	01 c0                	add    %eax,%eax$/;"	l
eea	sh.asm	/^     eea:	89 c2                	mov    %eax,%edx$/;"	l
eec	sh.asm	/^     eec:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
eef	sh.asm	/^     eef:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ef	ln.asm	/^  ef:	0f b6 10             	movzbl (%eax),%edx$/;"	l
ef2	sh.asm	/^     ef2:	0f be c0             	movsbl %al,%eax$/;"	l
ef5	sh.asm	/^     ef5:	01 d0                	add    %edx,%eax$/;"	l
ef7	sh.asm	/^     ef7:	83 e8 30             	sub    $0x30,%eax$/;"	l
efa	sh.asm	/^     efa:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
efd	sh.asm	/^     efd:	83 45 08 01          	addl   $0x1,0x8(%ebp)$/;"	l
efile	sh.c	/^  char *efile;$/;"	m	struct:redircmd	file:
eflags	kernel.asm	/^  eflags = readeflags();$/;"	d
eflags	mmu.h	/^  uint eflags;$/;"	m	struct:taskstate
eflags	x86.h	/^  uint eflags;$/;"	m	struct:trapframe
ehsize	elf.h	/^  ushort ehsize;$/;"	m	struct:elfhdr
eip	mmu.h	/^  uint *eip;         \/\/ Saved state from last task switch$/;"	m	struct:taskstate
eip	proc.h	/^  uint eip;$/;"	m	struct:context
eip	x86.h	/^  uint eip;$/;"	m	struct:trapframe
elf	bootblock.asm	/^  elf = (struct elfhdr*)0x10000;  \/\/ scratch space$/;"	d
elf	elf.h	/^  uchar elf[12];$/;"	m	struct:elfhdr
elfhdr	elf.h	/^struct elfhdr {$/;"	s
empty	kernel.asm	/^      empty = ip;$/;"	d
empty	kernel.asm	/^  empty = 0;$/;"	d
entry	bootblock.asm	/^  entry = (void(*)(void))(elf->entry);$/;"	d
entry	elf.h	/^  uint entry;$/;"	m	struct:elfhdr
entry	entry.S	/^entry:$/;"	l
entry	kernel.asm	/^entry:$/;"	l
entry	mp.h	/^  ushort entry;                 \/\/ entry count$/;"	m	struct:mpconf
entrypgdir	main.c	/^pde_t entrypgdir[NPDENTRIES] = {$/;"	v
entrypgdir	main.c	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	v
ep	kernel.asm	/^  ep = (char*)p->sz;$/;"	d
epa	bootblock.asm	/^  epa = pa + count;$/;"	d
eph	bootblock.asm	/^  eph = ph + elf->phnum;$/;"	d
err	x86.h	/^  uint err;$/;"	m	struct:trapframe
es	mmu.h	/^  ushort es;         \/\/ Even more saved state (segment selectors)$/;"	m	struct:taskstate
es	sh.asm	/^  es = s + strlen(s);$/;"	d
es	x86.h	/^  ushort es;$/;"	m	struct:trapframe
esi	mmu.h	/^  uint esi;$/;"	m	struct:taskstate
esi	proc.h	/^  uint esi;$/;"	m	struct:context
esi	x86.h	/^  uint esi;$/;"	m	struct:trapframe
esp	mmu.h	/^  uint *esp;$/;"	m	struct:taskstate
esp	uthread.h	/^	int 	       	esp;        \/* current stack pointer *\/$/;"	m	struct:uthread
esp	x86.h	/^  uint esp;$/;"	m	struct:trapframe
esp0	mmu.h	/^  uint esp0;         \/\/ Stack pointers and segment selectors$/;"	m	struct:taskstate
esp1	mmu.h	/^  uint *esp1;$/;"	m	struct:taskstate
esp2	mmu.h	/^  uint *esp2;$/;"	m	struct:taskstate
exec	exec.c	/^exec(char *path, char **argv)$/;"	f
execcmd	sh.c	/^execcmd(void)$/;"	f
execcmd	sh.c	/^struct execcmd {$/;"	s	file:
exit	initcode.S	/^exit:$/;"	l
exit	initcode.asm	/^exit:$/;"	l
exit	proc.c	/^exit(void)$/;"	f
f	Makefile	/^	dd if=\/dev\/zero of=xv6.img count=10000$/;"	m
f	Makefile	/^	dd if=\/dev\/zero of=xv6memfs.img count=10000$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=bootblock of=xv6memfs.img conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernel of=xv6.img seek=1 conv=notrunc$/;"	m
f	Makefile	/^	dd if=kernelmemfs of=xv6memfs.img seek=1 conv=notrunc$/;"	m
f	cat.asm	/^   f:	c7 44 24 04 80 0b 00 	movl   $0xb80,0x4(%esp)$/;"	l
f	kill.asm	/^   f:	c7 44 24 04 03 08 00 	movl   $0x803,0x4(%esp)$/;"	l
f	ln.asm	/^   f:	c7 44 24 04 1b 08 00 	movl   $0x81b,0x4(%esp)$/;"	l
f	mkdir.asm	/^   f:	c7 44 24 04 23 08 00 	movl   $0x823,0x4(%esp)$/;"	l
f	rm.asm	/^   f:	c7 44 24 04 23 08 00 	movl   $0x823,0x4(%esp)$/;"	l
f0	grep.asm	/^  f0:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f0	kill.asm	/^  f0:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f0	mkdir.asm	/^  f0:	84 c0                	test   %al,%al$/;"	l
f0	rm.asm	/^  f0:	84 c0                	test   %al,%al$/;"	l
f0	zombie.asm	/^  f0:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f01	sh.asm	/^     f01:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f04	sh.asm	/^     f04:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f07	sh.asm	/^     f07:	3c 2f                	cmp    $0x2f,%al$/;"	l
f09	sh.asm	/^     f09:	7e 0a                	jle    f15 <atoi+0x46>$/;"	l
f0b	sh.asm	/^     f0b:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f0e	sh.asm	/^     f0e:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f1	echo.asm	/^  f1:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f1	init.asm	/^  f1:	e8 8a 02 00 00       	call   380 <wait>$/;"	l
f1	ls.asm	/^  f1:	e9 01 02 00 00       	jmp    2f7 <ls+0x249>$/;"	l
f1	sh.asm	/^      f1:	85 c0                	test   %eax,%eax$/;"	l
f11	sh.asm	/^     f11:	3c 39                	cmp    $0x39,%al$/;"	l
f13	sh.asm	/^     f13:	7e c9                	jle    ede <atoi+0xf>$/;"	l
f15	sh.asm	/^     f15:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
f18	sh.asm	/^     f18:	c9                   	leave  $/;"	l
f19	sh.asm	/^     f19:	c3                   	ret    $/;"	l
f1a	sh.asm	/^     f1a:	55                   	push   %ebp$/;"	l
f1b	sh.asm	/^     f1b:	89 e5                	mov    %esp,%ebp$/;"	l
f1d	sh.asm	/^     f1d:	83 ec 10             	sub    $0x10,%esp$/;"	l
f2	cat.asm	/^  f2:	89 04 24             	mov    %eax,(%esp)$/;"	l
f2	ln.asm	/^  f2:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f2	mkdir.asm	/^  f2:	74 10                	je     104 <strcmp+0x27>$/;"	l
f2	rm.asm	/^  f2:	74 10                	je     104 <strcmp+0x27>$/;"	l
f20	sh.asm	/^     f20:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f23	sh.asm	/^     f23:	89 45 fc             	mov    %eax,-0x4(%ebp)$/;"	l
f26	sh.asm	/^     f26:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
f29	sh.asm	/^     f29:	89 45 f8             	mov    %eax,-0x8(%ebp)$/;"	l
f2c	sh.asm	/^     f2c:	eb 13                	jmp    f41 <memmove+0x27>$/;"	l
f2e	sh.asm	/^     f2e:	8b 45 f8             	mov    -0x8(%ebp),%eax$/;"	l
f3	grep.asm	/^  f3:	89 04 24             	mov    %eax,(%esp)$/;"	l
f3	kill.asm	/^  f3:	0f b6 c0             	movzbl %al,%eax$/;"	l
f3	sh.asm	/^      f3:	75 0e                	jne    103 <runcmd+0x103>$/;"	l
f3	zombie.asm	/^  f3:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
f31	sh.asm	/^     f31:	0f b6 10             	movzbl (%eax),%edx$/;"	l
f34	sh.asm	/^     f34:	8b 45 fc             	mov    -0x4(%ebp),%eax$/;"	l
f37	sh.asm	/^     f37:	88 10                	mov    %dl,(%eax)$/;"	l
f39	sh.asm	/^     f39:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)$/;"	l
f3d	sh.asm	/^     f3d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)$/;"	l
f4	echo.asm	/^  f4:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f4	mkdir.asm	/^  f4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f4	rm.asm	/^  f4:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f4	wc.asm	/^  f4:	00 $/;"	l
f41	sh.asm	/^     f41:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)$/;"	l
f45	sh.asm	/^     f45:	0f 9f c0             	setg   %al$/;"	l
f48	sh.asm	/^     f48:	83 6d 10 01          	subl   $0x1,0x10(%ebp)$/;"	l
f4c	sh.asm	/^     f4c:	84 c0                	test   %al,%al$/;"	l
f4e	sh.asm	/^     f4e:	75 de                	jne    f2e <memmove+0x14>$/;"	l
f5	cat.asm	/^  f5:	e8 a2 02 00 00       	call   39c <close>$/;"	l
f5	ln.asm	/^  f5:	0f b6 00             	movzbl (%eax),%eax$/;"	l
f5	sh.asm	/^      f5:	8b 45 ec             	mov    -0x14(%ebp),%eax$/;"	l
f5	wc.asm	/^  f5:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)$/;"	l
f50	sh.asm	/^     f50:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f53	sh.asm	/^     f53:	c9                   	leave  $/;"	l
f54	sh.asm	/^     f54:	c3                   	ret    $/;"	l
f55	sh.asm	/^     f55:	90                   	nop$/;"	l
f56	sh.asm	/^     f56:	90                   	nop$/;"	l
f57	sh.asm	/^     f57:	90                   	nop$/;"	l
f58	sh.asm	/^     f58:	b8 01 00 00 00       	mov    $0x1,%eax$/;"	l
f5d	sh.asm	/^     f5d:	cd 40                	int    $0x40$/;"	l
f5f	sh.asm	/^     f5f:	c3                   	ret    $/;"	l
f6	grep.asm	/^  f6:	e8 d1 04 00 00       	call   5cc <read>$/;"	l
f6	init.asm	/^  f6:	89 44 24 18          	mov    %eax,0x18(%esp)$/;"	l
f6	kill.asm	/^  f6:	89 d1                	mov    %edx,%ecx$/;"	l
f6	ls.asm	/^  f6:	8d 85 bc fd ff ff    	lea    -0x244(%ebp),%eax$/;"	l
f60	sh.asm	/^     f60:	b8 02 00 00 00       	mov    $0x2,%eax$/;"	l
f65	sh.asm	/^     f65:	cd 40                	int    $0x40$/;"	l
f67	sh.asm	/^     f67:	c3                   	ret    $/;"	l
f68	sh.asm	/^     f68:	b8 03 00 00 00       	mov    $0x3,%eax$/;"	l
f6d	sh.asm	/^     f6d:	cd 40                	int    $0x40$/;"	l
f6f	sh.asm	/^     f6f:	c3                   	ret    $/;"	l
f7	echo.asm	/^  f7:	0f b6 c0             	movzbl %al,%eax$/;"	l
f7	mkdir.asm	/^  f7:	0f b6 10             	movzbl (%eax),%edx$/;"	l
f7	rm.asm	/^  f7:	0f b6 10             	movzbl (%eax),%edx$/;"	l
f7	zombie.asm	/^  f7:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
f70	sh.asm	/^     f70:	b8 04 00 00 00       	mov    $0x4,%eax$/;"	l
f75	sh.asm	/^     f75:	cd 40                	int    $0x40$/;"	l
f77	sh.asm	/^     f77:	c3                   	ret    $/;"	l
f78	sh.asm	/^     f78:	b8 05 00 00 00       	mov    $0x5,%eax$/;"	l
f7d	sh.asm	/^     f7d:	cd 40                	int    $0x40$/;"	l
f7f	sh.asm	/^     f7f:	c3                   	ret    $/;"	l
f8	kill.asm	/^  f8:	29 c1                	sub    %eax,%ecx$/;"	l
f8	ln.asm	/^  f8:	38 c2                	cmp    %al,%dl$/;"	l
f8	sh.asm	/^      f8:	8b 40 04             	mov    0x4(%eax),%eax$/;"	l
f80	sh.asm	/^     f80:	b8 10 00 00 00       	mov    $0x10,%eax$/;"	l
f85	sh.asm	/^     f85:	cd 40                	int    $0x40$/;"	l
f87	sh.asm	/^     f87:	c3                   	ret    $/;"	l
f88	sh.asm	/^     f88:	b8 15 00 00 00       	mov    $0x15,%eax$/;"	l
f8d	sh.asm	/^     f8d:	cd 40                	int    $0x40$/;"	l
f8f	sh.asm	/^     f8f:	c3                   	ret    $/;"	l
f90	sh.asm	/^     f90:	b8 06 00 00 00       	mov    $0x6,%eax$/;"	l
f95	sh.asm	/^     f95:	cd 40                	int    $0x40$/;"	l
f97	sh.asm	/^     f97:	c3                   	ret    $/;"	l
f98	sh.asm	/^     f98:	b8 07 00 00 00       	mov    $0x7,%eax$/;"	l
f9d	sh.asm	/^     f9d:	cd 40                	int    $0x40$/;"	l
f9f	sh.asm	/^     f9f:	c3                   	ret    $/;"	l
fa	cat.asm	/^  fa:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)$/;"	l
fa	echo.asm	/^  fa:	89 d1                	mov    %edx,%ecx$/;"	l
fa	init.asm	/^  fa:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)$/;"	l
fa	kill.asm	/^  fa:	89 c8                	mov    %ecx,%eax$/;"	l
fa	ln.asm	/^  fa:	74 de                	je     da <strcmp+0x5>$/;"	l
fa	mkdir.asm	/^  fa:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
fa	rm.asm	/^  fa:	8b 45 0c             	mov    0xc(%ebp),%eax$/;"	l
fa	zombie.asm	/^  fa:	89 04 24             	mov    %eax,(%esp)$/;"	l
fa0	sh.asm	/^     fa0:	b8 0f 00 00 00       	mov    $0xf,%eax$/;"	l
fa5	sh.asm	/^     fa5:	cd 40                	int    $0x40$/;"	l
fa7	sh.asm	/^     fa7:	c3                   	ret    $/;"	l
fa8	sh.asm	/^     fa8:	b8 11 00 00 00       	mov    $0x11,%eax$/;"	l
fad	sh.asm	/^     fad:	cd 40                	int    $0x40$/;"	l
faf	sh.asm	/^     faf:	c3                   	ret    $/;"	l
fb	grep.asm	/^  fb:	89 45 ec             	mov    %eax,-0x14(%ebp)$/;"	l
fb	sh.asm	/^      fb:	89 04 24             	mov    %eax,(%esp)$/;"	l
fb0	sh.asm	/^     fb0:	b8 12 00 00 00       	mov    $0x12,%eax$/;"	l
fb5	sh.asm	/^     fb5:	cd 40                	int    $0x40$/;"	l
fb7	sh.asm	/^     fb7:	c3                   	ret    $/;"	l
fb8	sh.asm	/^     fb8:	b8 08 00 00 00       	mov    $0x8,%eax$/;"	l
fbd	sh.asm	/^     fbd:	cd 40                	int    $0x40$/;"	l
fbf	sh.asm	/^     fbf:	c3                   	ret    $/;"	l
fc	echo.asm	/^  fc:	29 c1                	sub    %eax,%ecx$/;"	l
fc	kill.asm	/^  fc:	5d                   	pop    %ebp$/;"	l
fc	ln.asm	/^  fc:	8b 45 08             	mov    0x8(%ebp),%eax$/;"	l
fc	ls.asm	/^  fc:	89 44 24 04          	mov    %eax,0x4(%esp)$/;"	l
fc	wc.asm	/^  fc:	e8 9e 04 00 00       	call   59f <printf>$/;"	l
fc0	sh.asm	/^     fc0:	b8 13 00 00 00       	mov    $0x13,%eax$/;"	l
fc5	sh.asm	/^     fc5:	cd 40                	int    $0x40$/;"	l
fc7	sh.asm	/^     fc7:	c3                   	ret    $/;"	l
fc8	sh.asm	/^     fc8:	b8 14 00 00 00       	mov    $0x14,%eax$/;"	l
fcd	sh.asm	/^     fcd:	cd 40                	int    $0x40$/;"	l
fcf	sh.asm	/^     fcf:	c3                   	ret    $/;"	l
fd	cat.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	echo.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	grep.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	init.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	kill.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	kill.asm	/^  fd:	c3                   	ret    $/;"	l
fd	ln.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	ls.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	mkdir.asm	/^  fd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
fd	rm.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	rm.asm	/^  fd:	0f b6 00             	movzbl (%eax),%eax$/;"	l
fd	sh.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	sh.c	/^  int fd;$/;"	m	struct:redircmd	file:
fd	wc.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	zombie.asm	/^  fd = open(n, O_RDONLY);$/;"	d
fd	zombie.asm	/^  fd:	e8 22 ff ff ff       	call   24 <stosb>$/;"	l
fd0	kernel.asm	/^  fd0 = -1;$/;"	d
fd0	sh.asm	/^     fd0:	b8 09 00 00 00       	mov    $0x9,%eax$/;"	l
fd5	sh.asm	/^     fd5:	cd 40                	int    $0x40$/;"	l
fd7	sh.asm	/^     fd7:	c3                   	ret    $/;"	l
fd8	sh.asm	/^     fd8:	b8 0a 00 00 00       	mov    $0xa,%eax$/;"	l
fdalloc	sysfile.c	/^fdalloc(struct file *f)$/;"	f	file:
fdd	sh.asm	/^     fdd:	cd 40                	int    $0x40$/;"	l
fdf	sh.asm	/^     fdf:	c3                   	ret    $/;"	l
fe	echo.asm	/^  fe:	89 c8                	mov    %ecx,%eax$/;"	l
fe	grep.asm	/^  fe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)$/;"	l
fe	kill.asm	/^  fe:	55                   	push   %ebp$/;"	l
fe	sh.asm	/^      fe:	e8 fd fe ff ff       	call   0 <runcmd>$/;"	l
fe0	sh.asm	/^     fe0:	b8 0b 00 00 00       	mov    $0xb,%eax$/;"	l
fe5	sh.asm	/^     fe5:	cd 40                	int    $0x40$/;"	l
fe7	sh.asm	/^     fe7:	c3                   	ret    $/;"	l
fe8	sh.asm	/^     fe8:	b8 0c 00 00 00       	mov    $0xc,%eax$/;"	l
feature	mp.h	/^  uint feature;                 \/\/ feature flags from CPUID instruction$/;"	m	struct:mpproc
fed	sh.asm	/^     fed:	cd 40                	int    $0x40$/;"	l
fef	sh.asm	/^     fef:	c3                   	ret    $/;"	l
fetchint	syscall.c	/^fetchint(struct proc *p, uint addr, int *ip)$/;"	f
fetchstr	syscall.c	/^fetchstr(struct proc *p, uint addr, char **pp)$/;"	f
ff	cat.asm	/^  ff:	8b 44 24 1c          	mov    0x1c(%esp),%eax$/;"	l
ff	init.asm	/^  ff:	0f 88 66 ff ff ff    	js     6b <main+0x6b>$/;"	l
ff	kernel.asm	/^  ff = *f;$/;"	d
ff	kill.asm	/^  ff:	89 e5                	mov    %esp,%ebp$/;"	l
ff	ln.asm	/^  ff:	0f b6 00             	movzbl (%eax),%eax$/;"	l
ff0	sh.asm	/^     ff0:	b8 0d 00 00 00       	mov    $0xd,%eax$/;"	l
ff5	sh.asm	/^     ff5:	cd 40                	int    $0x40$/;"	l
ff7	sh.asm	/^     ff7:	c3                   	ret    $/;"	l
ff8	sh.asm	/^     ff8:	b8 0e 00 00 00       	mov    $0xe,%eax$/;"	l
ffd	sh.asm	/^     ffd:	cd 40                	int    $0x40$/;"	l
fff	sh.asm	/^     fff:	c3                   	ret    $/;"	l
file	file.c	/^  struct file file[NFILE];$/;"	m	struct:__anon4	typeref:struct:__anon4::file	file:
file	file.h	/^struct file {$/;"	s
file	sh.c	/^  char *file;$/;"	m	struct:redircmd	file:
filealloc	file.c	/^filealloc(void)$/;"	f
fileclose	file.c	/^fileclose(struct file *f)$/;"	f
filedup	file.c	/^filedup(struct file *f)$/;"	f
fileinit	file.c	/^fileinit(void)$/;"	f
fileread	file.c	/^fileread(struct file *f, char *addr, int n)$/;"	f
filestat	file.c	/^filestat(struct file *f, struct stat *st)$/;"	f
filesz	elf.h	/^  uint filesz;$/;"	m	struct:proghdr
filewrite	file.c	/^filewrite(struct file *f, char *addr, int n)$/;"	f
first	kernel.asm	/^    first = 0;$/;"	d
flags	buf.h	/^  int flags;$/;"	m	struct:buf
flags	elf.h	/^  uint flags;$/;"	m	struct:elfhdr
flags	elf.h	/^  uint flags;$/;"	m	struct:proghdr
flags	file.h	/^  int flags;          \/\/ I_BUSY, I_VALID$/;"	m	struct:inode
flags	mp.h	/^  uchar flags;                  \/\/ CPU flags$/;"	m	struct:mpproc
flags	mp.h	/^  uchar flags;                  \/\/ I\/O APIC flags$/;"	m	struct:mpioapic
fmtname	ls.c	/^fmtname(char *path)$/;"	f
fork	proc.c	/^fork(void)$/;"	f
fork1	sh.c	/^fork1(void)$/;"	f
forkret	proc.c	/^forkret(void)$/;"	f
found	kernel.asm	/^found:$/;"	l
free	umalloc.c	/^free(void *ap)$/;"	f
freeblock	mkfs.c	/^uint freeblock;$/;"	v
freeinode	mkfs.c	/^uint freeinode = 1;$/;"	v
freelist	kalloc.c	/^  struct run *freelist;$/;"	m	struct:__anon7	typeref:struct:__anon7::run	file:
freep	cat.asm	/^      freep = prevp;$/;"	d
freep	cat.asm	/^  freep = p;$/;"	d
freep	echo.asm	/^      freep = prevp;$/;"	d
freep	echo.asm	/^  freep = p;$/;"	d
freep	grep.asm	/^      freep = prevp;$/;"	d
freep	grep.asm	/^  freep = p;$/;"	d
freep	init.asm	/^      freep = prevp;$/;"	d
freep	init.asm	/^  freep = p;$/;"	d
freep	kill.asm	/^      freep = prevp;$/;"	d
freep	kill.asm	/^  freep = p;$/;"	d
freep	ln.asm	/^      freep = prevp;$/;"	d
freep	ln.asm	/^  freep = p;$/;"	d
freep	ls.asm	/^      freep = prevp;$/;"	d
freep	ls.asm	/^  freep = p;$/;"	d
freep	mkdir.asm	/^      freep = prevp;$/;"	d
freep	mkdir.asm	/^  freep = p;$/;"	d
freep	rm.asm	/^      freep = prevp;$/;"	d
freep	rm.asm	/^  freep = p;$/;"	d
freep	sh.asm	/^      freep = prevp;$/;"	d
freep	sh.asm	/^  freep = p;$/;"	d
freep	umalloc.c	/^static Header *freep;$/;"	v	file:
freep	wc.asm	/^      freep = prevp;$/;"	d
freep	wc.asm	/^  freep = p;$/;"	d
freep	zombie.asm	/^      freep = prevp;$/;"	d
freep	zombie.asm	/^  freep = p;$/;"	d
freerange	kalloc.c	/^freerange(void *vstart, void *vend)$/;"	f
freevm	vm.c	/^freevm(pde_t *pgdir)$/;"	f
fs	mmu.h	/^  ushort fs;$/;"	m	struct:taskstate
fs	x86.h	/^  ushort fs;$/;"	m	struct:trapframe
fsfd	mkfs.c	/^int fsfd;$/;"	v
ftable	file.c	/^} ftable;$/;"	v	typeref:struct:__anon4
g	mmu.h	/^  uint g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:segdesc
gatedesc	mmu.h	/^struct gatedesc {$/;"	s
gdt	bootasm.S	/^gdt:$/;"	l
gdt	entryother.S	/^gdt:$/;"	l
gdt	proc.h	/^  struct segdesc gdt[NSEGS];   \/\/ x86 global descriptor table$/;"	m	struct:cpu	typeref:struct:cpu::segdesc
gdt	vm.c	/^struct segdesc gdt[NSEGS];$/;"	v	typeref:struct:segdesc
gdtdesc	bootasm.S	/^gdtdesc:$/;"	l
gdtdesc	entryother.S	/^gdtdesc:$/;"	l
getcallerpcs	spinlock.c	/^getcallerpcs(void *v, uint pcs[])$/;"	f
getcmd	sh.c	/^getcmd(char *buf, int nbuf)$/;"	f
gets	ulib.c	/^gets(char *buf, int max)$/;"	f
gettoken	sh.c	/^gettoken(char **ps, char *es, char **q, char **eq)$/;"	f
grep	grep.c	/^grep(char *pattern, int fd)$/;"	f
growproc	proc.c	/^growproc(int n)$/;"	f
gs	mmu.h	/^  ushort gs;$/;"	m	struct:taskstate
gs	x86.h	/^  ushort gs;$/;"	m	struct:trapframe
havedisk1	ide.c	/^static int havedisk1;$/;"	v	file:
havedisk1	kernel.asm	/^      havedisk1 = 1;$/;"	d
havekids	kernel.asm	/^      havekids = 1;$/;"	d
havekids	kernel.asm	/^    havekids = 0;$/;"	d
head	bio.c	/^  struct buf head;$/;"	m	struct:__anon1	typeref:struct:__anon1::buf	file:
header	umalloc.c	/^union header {$/;"	u	file:
holding	spinlock.c	/^holding(struct spinlock *lock)$/;"	f
hp	cat.asm	/^  hp = (Header*)p;$/;"	d
hp	echo.asm	/^  hp = (Header*)p;$/;"	d
hp	grep.asm	/^  hp = (Header*)p;$/;"	d
hp	init.asm	/^  hp = (Header*)p;$/;"	d
hp	kill.asm	/^  hp = (Header*)p;$/;"	d
hp	ln.asm	/^  hp = (Header*)p;$/;"	d
hp	ls.asm	/^  hp = (Header*)p;$/;"	d
hp	mkdir.asm	/^  hp = (Header*)p;$/;"	d
hp	rm.asm	/^  hp = (Header*)p;$/;"	d
hp	sh.asm	/^  hp = (Header*)p;$/;"	d
hp	wc.asm	/^  hp = (Header*)p;$/;"	d
hp	zombie.asm	/^  hp = (Header*)p;$/;"	d
i	cat.asm	/^  i = 0;$/;"	d
i	echo.asm	/^  i = 0;$/;"	d
i	grep.asm	/^  i = 0;$/;"	d
i	init.asm	/^  i = 0;$/;"	d
i	kernel.asm	/^  i = 0;$/;"	d
i	kill.asm	/^  i = 0;$/;"	d
i	ln.asm	/^  i = 0;$/;"	d
i	ls.asm	/^  i = 0;$/;"	d
i	mkdir.asm	/^  i = 0;$/;"	d
i	rm.asm	/^  i = 0;$/;"	d
i	sh.asm	/^  i = 0;$/;"	d
i	wc.asm	/^  i = 0;$/;"	d
i	zombie.asm	/^  i = 0;$/;"	d
i2b	mkfs.c	/^i2b(uint inum)$/;"	f
ialloc	fs.c	/^ialloc(uint dev, short type)$/;"	f
ialloc	mkfs.c	/^ialloc(ushort type)$/;"	f
iappend	mkfs.c	/^iappend(uint inum, void *xp, int n)$/;"	f
icache	fs.c	/^} icache;$/;"	v	typeref:struct:__anon6
id	kernel.asm	/^  id = ioapicread(REG_ID) >> 24;$/;"	d
id	proc.h	/^  uchar id;                    \/\/ Local APIC ID; index into cpus[] below$/;"	m	struct:cpu
ideinit	ide.c	/^ideinit(void)$/;"	f
ideinit	memide.c	/^ideinit(void)$/;"	f
ideintr	ide.c	/^ideintr(void)$/;"	f
ideintr	memide.c	/^ideintr(void)$/;"	f
idelock	ide.c	/^static struct spinlock idelock;$/;"	v	typeref:struct:spinlock	file:
idequeue	ide.c	/^static struct buf *idequeue;$/;"	v	typeref:struct:buf	file:
idequeue	kernel.asm	/^  idequeue = b->qnext;$/;"	d
iderw	ide.c	/^iderw(struct buf *b)$/;"	f
iderw	memide.c	/^iderw(struct buf *b)$/;"	f
idestart	ide.c	/^idestart(struct buf *b)$/;"	f	file:
idewait	ide.c	/^idewait(int checkerr)$/;"	f	file:
idt	trap.c	/^struct gatedesc idt[256];$/;"	v	typeref:struct:gatedesc
idtinit	trap.c	/^idtinit(void)$/;"	f
idup	fs.c	/^idup(struct inode *ip)$/;"	f
iget	fs.c	/^iget(uint dev, uint inum)$/;"	f	file:
iinit	fs.c	/^iinit(void)$/;"	f
ilock	fs.c	/^ilock(struct inode *ip)$/;"	f
imcrp	mp.h	/^  uchar imcrp;$/;"	m	struct:mp
inb	x86.h	/^inb(ushort port)$/;"	f
init	initcode.S	/^init:$/;"	l
initlock	spinlock.c	/^initlock(struct spinlock *lk, char *name)$/;"	f
initlog	log.c	/^initlog(void)$/;"	f
initproc	kernel.asm	/^  initproc = p;$/;"	d
initproc	proc.c	/^static struct proc *initproc;$/;"	v	typeref:struct:proc	file:
inituvm	vm.c	/^inituvm(pde_t *pgdir, char *init, uint sz)$/;"	f
ino	stat.h	/^  uint ino;    \/\/ Inode number on device$/;"	m	struct:stat
inode	file.h	/^struct inode {$/;"	s
inode	fs.c	/^  struct inode inode[NINODE];$/;"	m	struct:__anon6	typeref:struct:__anon6::inode	file:
input	console.c	/^} input;$/;"	v	typeref:struct:__anon3
insl	x86.h	/^insl(int port, void *addr, int cnt)$/;"	f
install_trans	log.c	/^install_trans(void)$/;"	f	file:
int	cat.asm	/^int$/;"	l
int	echo.asm	/^int$/;"	l
int	grep.asm	/^int match(char*, char*);$/;"	l
int	grep.asm	/^int matchhere(char *re, char *text)$/;"	l
int	grep.asm	/^int matchhere(char*, char*);$/;"	l
int	grep.asm	/^int matchstar(int c, char *re, char *text)$/;"	l
int	grep.asm	/^int matchstar(int, char*, char*);$/;"	l
int	grep.asm	/^int$/;"	l
int	init.asm	/^int$/;"	l
int	kernel.asm	/^int ncpu;$/;"	l
int	kernel.asm	/^int$/;"	l
int	kill.asm	/^int$/;"	l
int	ln.asm	/^int$/;"	l
int	ls.asm	/^int$/;"	l
int	mkdir.asm	/^int$/;"	l
int	rm.asm	/^int$/;"	l
int	sh.asm	/^int$/;"	l
int	wc.asm	/^int$/;"	l
int	zombie.asm	/^int$/;"	l
intena	kernel.asm	/^  intena = cpu->intena;$/;"	d
intena	proc.h	/^  int intena;                  \/\/ Were interrupts enabled before pushcli?$/;"	m	struct:cpu
inum	file.h	/^  uint inum;          \/\/ Inode number$/;"	m	struct:inode
inum	fs.h	/^  ushort inum;$/;"	m	struct:dirent
inum	kernel.asm	/^      inum = de.inum;$/;"	d
inword	wc.asm	/^        inword = 0;$/;"	d
inword	wc.asm	/^        inword = 1;$/;"	d
inword	wc.asm	/^  inword = 0;$/;"	d
ioapic	ioapic.c	/^struct ioapic {$/;"	s	file:
ioapic	ioapic.c	/^volatile struct ioapic *ioapic;$/;"	v	typeref:struct:ioapic
ioapic	kernel.asm	/^      ioapic = (struct mpioapic*)p;$/;"	d
ioapic	kernel.asm	/^  ioapic = (volatile struct ioapic*)IOAPIC;$/;"	d
ioapicenable	ioapic.c	/^ioapicenable(int irq, int cpunum)$/;"	f
ioapicid	kernel.asm	/^      ioapicid = ioapic->apicno;$/;"	d
ioapicid	kernel.asm	/^    ioapicid = 0;$/;"	d
ioapicid	mp.c	/^uchar ioapicid;$/;"	v
ioapicinit	ioapic.c	/^ioapicinit(void)$/;"	f
ioapicread	ioapic.c	/^ioapicread(int reg)$/;"	f	file:
ioapicwrite	ioapic.c	/^ioapicwrite(int reg, uint data)$/;"	f	file:
iomb	mmu.h	/^  ushort iomb;       \/\/ I\/O map base address$/;"	m	struct:taskstate
ip	file.h	/^  struct inode *ip;$/;"	m	struct:file	typeref:struct:file::inode
ip	kernel.asm	/^    ip = create(path, T_FILE, 0, 0);$/;"	d
ip	kernel.asm	/^    ip = idup(proc->cwd);$/;"	d
ip	kernel.asm	/^    ip = iget(ROOTDEV, ROOTINO);$/;"	d
ip	kernel.asm	/^    ip = next;$/;"	d
ip	kernel.asm	/^  ip = 0;$/;"	d
ip	kernel.asm	/^  ip = empty;$/;"	d
iput	fs.c	/^iput(struct inode *ip)$/;"	f
irqmask	kernel.asm	/^  irqmask = mask;$/;"	d
irqmask	picirq.c	/^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	v	file:
isdirempty	sysfile.c	/^isdirempty(struct inode *dp)$/;"	f	file:
ismp	kernel.asm	/^        ismp = 0;$/;"	d
ismp	kernel.asm	/^      ismp = 0;$/;"	d
ismp	kernel.asm	/^  ismp = 1;$/;"	d
ismp	mp.c	/^int ismp;$/;"	v
itrunc	fs.c	/^itrunc(struct inode *ip)$/;"	f	file:
iunlock	fs.c	/^iunlock(struct inode *ip)$/;"	f
iunlockput	fs.c	/^iunlockput(struct inode *ip)$/;"	f
iupdate	fs.c	/^iupdate(struct inode *ip)$/;"	f
kalloc	kalloc.c	/^kalloc(void)$/;"	f
kbdgetc	kbd.c	/^kbdgetc(void)$/;"	f
kbdintr	kbd.c	/^kbdintr(void)$/;"	f
kernel	kernel.asm	/^kernel:     file format elf32-i386$/;"	l
kfree	kalloc.c	/^kfree(char *v)$/;"	f
kill	proc.c	/^kill(int pid)$/;"	f
killed	proc.h	/^  int killed;                  \/\/ If non-zero, have been killed$/;"	m	struct:proc
kinit1	kalloc.c	/^kinit1(void *vstart, void *vend)$/;"	f
kinit2	kalloc.c	/^kinit2(void *vstart, void *vend)$/;"	f
kmap	vm.c	/^static struct kmap {$/;"	s	file:
kmap	vm.c	/^} kmap[] = {$/;"	v	typeref:struct:kmap	file:
kmem	kalloc.c	/^} kmem;$/;"	v	typeref:struct:__anon7
kpgdir	kernel.asm	/^  kpgdir = setupkvm();$/;"	d
kpgdir	vm.c	/^pde_t *kpgdir;  \/\/ for use in scheduler()$/;"	v
kstack	proc.h	/^  char *kstack;                \/\/ Bottom of kernel stack for this process$/;"	m	struct:proc
kvmalloc	vm.c	/^kvmalloc(void)$/;"	f
l	wc.asm	/^  l = w = c = 0;$/;"	d
lapic	kernel.asm	/^    lapic = 0;$/;"	d
lapic	kernel.asm	/^  lapic = (uint*)conf->lapicaddr;$/;"	d
lapic	lapic.c	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	v
lapicaddr	mp.h	/^  uint *lapicaddr;              \/\/ address of local APIC$/;"	m	struct:mpconf
lapiceoi	lapic.c	/^lapiceoi(void)$/;"	f
lapicinit	lapic.c	/^lapicinit(int c)$/;"	f
lapicstartap	lapic.c	/^lapicstartap(uchar apicid, uint addr)$/;"	f
lapicw	lapic.c	/^lapicw(int index, int value)$/;"	f	file:
last	kernel.asm	/^      last = s+1;$/;"	d
last	kernel.asm	/^  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);$/;"	d
lcmd	sh.asm	/^    lcmd = (struct listcmd*)cmd;$/;"	d
lcr3	x86.h	/^lcr3(uint val) $/;"	f
ldt	mmu.h	/^  ushort ldt;$/;"	m	struct:taskstate
left	sh.c	/^  struct cmd *left;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
left	sh.c	/^  struct cmd *left;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
len	kernel.asm	/^  len = path - s;$/;"	d
length	mp.h	/^  uchar length;                 \/\/ 1$/;"	m	struct:mp
length	mp.h	/^  ushort length;                \/\/ total table length$/;"	m	struct:mpconf
lgdt	x86.h	/^lgdt(struct segdesc *p, int size)$/;"	f
lh	log.c	/^  struct logheader lh;$/;"	m	struct:log	typeref:struct:log::logheader	file:
lidt	x86.h	/^lidt(struct gatedesc *p, int size)$/;"	f
lim_15_0	mmu.h	/^  uint lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:segdesc
lim_19_16	mmu.h	/^  uint lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:segdesc
link	mmu.h	/^  uint link;         \/\/ Old ts selector$/;"	m	struct:taskstate
listcmd	sh.c	/^listcmd(struct cmd *left, struct cmd *right)$/;"	f
listcmd	sh.c	/^struct listcmd {$/;"	s	file:
loadgs	x86.h	/^loadgs(ushort v)$/;"	f
loaduvm	vm.c	/^loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)$/;"	f
lock	bio.c	/^  struct spinlock lock;$/;"	m	struct:__anon1	typeref:struct:__anon1::spinlock	file:
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::spinlock	file:
lock	console.c	/^  struct spinlock lock;$/;"	m	struct:__anon3	typeref:struct:__anon3::spinlock	file:
lock	file.c	/^  struct spinlock lock;$/;"	m	struct:__anon4	typeref:struct:__anon4::spinlock	file:
lock	fs.c	/^  struct spinlock lock;$/;"	m	struct:__anon6	typeref:struct:__anon6::spinlock	file:
lock	kalloc.c	/^  struct spinlock lock;$/;"	m	struct:__anon7	typeref:struct:__anon7::spinlock	file:
lock	log.c	/^  struct spinlock lock;$/;"	m	struct:log	typeref:struct:log::spinlock	file:
lock	pipe.c	/^  struct spinlock lock;$/;"	m	struct:pipe	typeref:struct:pipe::spinlock	file:
lock	proc.c	/^  struct spinlock lock;$/;"	m	struct:__anon8	typeref:struct:__anon8::spinlock	file:
locked	spinlock.h	/^  uint locked;       \/\/ Is the lock held?$/;"	m	struct:spinlock
locking	console.c	/^  int locking;$/;"	m	struct:__anon2	file:
locking	kernel.asm	/^  locking = cons.locking;$/;"	d
log	log.c	/^struct log log;$/;"	v	typeref:struct:log
log	log.c	/^struct log {$/;"	s	file:
log_write	log.c	/^log_write(struct buf *b)$/;"	f
logheader	log.c	/^struct logheader {$/;"	s	file:
loop	kernel.asm	/^ loop:$/;"	l
ls	ls.c	/^ls(char *path)$/;"	f
ltr	x86.h	/^ltr(ushort sel)$/;"	f
m	grep.asm	/^      m = 0;$/;"	d
m	grep.asm	/^  m = 0;$/;"	d
m	kernel.asm	/^      m = 1 << (bi % 8);$/;"	d
m	kernel.asm	/^    m = min(n - tot, BSIZE - off%BSIZE);$/;"	d
m	kernel.asm	/^  m = 1 << (bi % 8);$/;"	d
machine	elf.h	/^  ushort machine;$/;"	m	struct:elfhdr
magic	elf.h	/^  uint magic;  \/\/ must equal ELF_MAGIC$/;"	m	struct:elfhdr
main	cat.c	/^main(int argc, char *argv[])$/;"	f
main	echo.c	/^main(int argc, char *argv[])$/;"	f
main	grep.c	/^main(int argc, char *argv[])$/;"	f
main	init.c	/^main(void)$/;"	f
main	kill.c	/^main(int argc, char **argv)$/;"	f
main	ln.c	/^main(int argc, char *argv[])$/;"	f
main	ls.c	/^main(int argc, char *argv[])$/;"	f
main	main.c	/^main(void)$/;"	f
main	mkdir.c	/^main(int argc, char *argv[])$/;"	f
main	mkfs.c	/^main(int argc, char *argv[])$/;"	f
main	rm.c	/^main(int argc, char *argv[])$/;"	f
main	sh.c	/^main(void)$/;"	f
main	wc.c	/^main(int argc, char *argv[])$/;"	f
main	zombie.c	/^main(void)$/;"	f
major	file.h	/^  short major;$/;"	m	struct:inode
major	fs.h	/^  short major;          \/\/ Major device number (T_DEV only)$/;"	m	struct:dinode
malloc	umalloc.c	/^malloc(uint nbytes)$/;"	f
mappages	vm.c	/^mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)$/;"	f	file:
match	grep.c	/^match(char *re, char *text)$/;"	f
matchhere	grep.c	/^int matchhere(char *re, char *text)$/;"	f
matchstar	grep.c	/^int matchstar(int c, char *re, char *text)$/;"	f
maxintr	kernel.asm	/^  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;$/;"	d
mem	kernel.asm	/^    mem = kalloc();$/;"	d
mem	kernel.asm	/^  mem = kalloc();$/;"	d
memcmp	string.c	/^memcmp(const void *v1, const void *v2, uint n)$/;"	f
memcpy	string.c	/^memcpy(void *dst, const void *src, uint n)$/;"	f
memdisk	memide.c	/^static uchar *memdisk;$/;"	v	file:
memmove	string.c	/^memmove(void *dst, const void *src, uint n)$/;"	f
memmove	ulib.c	/^memmove(void *vdst, void *vsrc, int n)$/;"	f
memset	string.c	/^memset(void *dst, int c, uint n)$/;"	f
memset	ulib.c	/^memset(void *dst, int c, uint n)$/;"	f
memsz	elf.h	/^  uint memsz;$/;"	m	struct:proghdr
microdelay	lapic.c	/^microdelay(int us)$/;"	f
min	fs.c	23;"	d	file:
min	mkfs.c	244;"	d	file:
minor	file.h	/^  short minor;$/;"	m	struct:inode
minor	fs.h	/^  short minor;          \/\/ Minor device number (T_DEV only)$/;"	m	struct:dinode
mode	sh.c	/^  int mode;$/;"	m	struct:redircmd	file:
morecore	umalloc.c	/^morecore(uint nu)$/;"	f	file:
mp	mp.h	/^struct mp {             \/\/ floating pointer$/;"	s
mpbcpu	mp.c	/^mpbcpu(void)$/;"	f
mpconf	mp.h	/^struct mpconf {         \/\/ configuration table header$/;"	s
mpconfig	mp.c	/^mpconfig(struct mp **pmp)$/;"	f	file:
mpenter	main.c	/^mpenter(void)$/;"	f	file:
mpinit	mp.c	/^mpinit(void)$/;"	f
mpioapic	mp.h	/^struct mpioapic {       \/\/ I\/O APIC table entry$/;"	s
mpmain	main.c	/^mpmain(void)$/;"	f	file:
mpproc	mp.h	/^struct mpproc {         \/\/ processor table entry$/;"	s
mpsearch	mp.c	/^mpsearch(void)$/;"	f	file:
mpsearch1	mp.c	/^mpsearch1(uint a, int len)$/;"	f	file:
multiboot_header	entry.S	/^multiboot_header:$/;"	l
n	cat.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	cat.asm	/^  n = 0;$/;"	d
n	echo.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	echo.asm	/^  n = 0;$/;"	d
n	grep.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	grep.asm	/^  n = 0;$/;"	d
n	init.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	init.asm	/^  n = 0;$/;"	d
n	kernel.asm	/^      n = PGSIZE;$/;"	d
n	kernel.asm	/^      n = len;$/;"	d
n	kernel.asm	/^      n = sz - i;$/;"	d
n	kernel.asm	/^    n = PGSIZE - (va - va0);$/;"	d
n	kernel.asm	/^    n = ip->size - off;$/;"	d
n	kill.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	kill.asm	/^  n = 0;$/;"	d
n	ln.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ln.asm	/^  n = 0;$/;"	d
n	log.c	/^  int n;   $/;"	m	struct:logheader	file:
n	ls.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	ls.asm	/^  n = 0;$/;"	d
n	mkdir.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	mkdir.asm	/^  n = 0;$/;"	d
n	rm.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	rm.asm	/^  n = 0;$/;"	d
n	sh.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	sh.asm	/^  n = 0;$/;"	d
n	wc.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	wc.asm	/^  n = 0;$/;"	d
n	zombie.asm	/^    n = n*10 + *s++ - '0';$/;"	d
n	zombie.asm	/^  n = 0;$/;"	d
n1	kernel.asm	/^        n1 = max;$/;"	d
name	cat.asm	/^  name: \\$/;"	l
name	echo.asm	/^  name: \\$/;"	l
name	fs.h	/^  char name[DIRSIZ];$/;"	m	struct:dirent
name	grep.asm	/^  name: \\$/;"	l
name	init.asm	/^  name: \\$/;"	l
name	kill.asm	/^  name: \\$/;"	l
name	ln.asm	/^  name: \\$/;"	l
name	ls.asm	/^  name: \\$/;"	l
name	mkdir.asm	/^  name: \\$/;"	l
name	proc.h	/^  char name[16];               \/\/ Process name (debugging)$/;"	m	struct:proc
name	rm.asm	/^  name: \\$/;"	l
name	sh.asm	/^  name: \\$/;"	l
name	spinlock.h	/^  char *name;        \/\/ Name of lock.$/;"	m	struct:spinlock
name	usys.S	/^  name: \\$/;"	l
name	wc.asm	/^  name: \\$/;"	l
name	zombie.asm	/^  name: \\$/;"	l
namecmp	fs.c	/^namecmp(const char *s, const char *t)$/;"	f
namei	fs.c	/^namei(char *path)$/;"	f
nameiparent	fs.c	/^nameiparent(char *path, char *name)$/;"	f
namex	fs.c	/^namex(char *path, int nameiparent, char *name)$/;"	f	file:
nblocks	fs.h	/^  uint nblocks;      \/\/ Number of data blocks$/;"	m	struct:superblock
nblocks	mkfs.c	/^int nblocks = 3981;$/;"	v
ncli	proc.h	/^  int ncli;                    \/\/ Depth of pushcli nesting.$/;"	m	struct:cpu
ncpu	kernel.asm	/^    ncpu = 1;$/;"	d
ncpu	mp.c	/^int ncpu;$/;"	v
neg	cat.asm	/^    neg = 1;$/;"	d
neg	cat.asm	/^  neg = 0;$/;"	d
neg	echo.asm	/^    neg = 1;$/;"	d
neg	echo.asm	/^  neg = 0;$/;"	d
neg	grep.asm	/^    neg = 1;$/;"	d
neg	grep.asm	/^  neg = 0;$/;"	d
neg	init.asm	/^    neg = 1;$/;"	d
neg	init.asm	/^  neg = 0;$/;"	d
neg	kill.asm	/^    neg = 1;$/;"	d
neg	kill.asm	/^  neg = 0;$/;"	d
neg	ln.asm	/^    neg = 1;$/;"	d
neg	ln.asm	/^  neg = 0;$/;"	d
neg	ls.asm	/^    neg = 1;$/;"	d
neg	ls.asm	/^  neg = 0;$/;"	d
neg	mkdir.asm	/^    neg = 1;$/;"	d
neg	mkdir.asm	/^  neg = 0;$/;"	d
neg	rm.asm	/^    neg = 1;$/;"	d
neg	rm.asm	/^  neg = 0;$/;"	d
neg	sh.asm	/^    neg = 1;$/;"	d
neg	sh.asm	/^  neg = 0;$/;"	d
neg	wc.asm	/^    neg = 1;$/;"	d
neg	wc.asm	/^  neg = 0;$/;"	d
neg	zombie.asm	/^    neg = 1;$/;"	d
neg	zombie.asm	/^  neg = 0;$/;"	d
next	buf.h	/^  struct buf *next;$/;"	m	struct:buf	typeref:struct:buf::buf
next	kalloc.c	/^  struct run *next;$/;"	m	struct:run	typeref:struct:run::run	file:
nextpid	proc.c	/^int nextpid = 1;$/;"	v
ninodes	fs.h	/^  uint ninodes;      \/\/ Number of inodes.$/;"	m	struct:superblock
ninodes	mkfs.c	/^int ninodes = 800;$/;"	v
nlink	file.h	/^  short nlink;$/;"	m	struct:inode
nlink	fs.h	/^  short nlink;          \/\/ Number of links to inode in file system$/;"	m	struct:dinode
nlink	stat.h	/^  short nlink; \/\/ Number of links to file$/;"	m	struct:stat
nlog	fs.h	/^  uint nlog;         \/\/ Number of log blocks$/;"	m	struct:superblock
nlog	mkfs.c	/^int nlog = LOGSIZE;$/;"	v
normalmap	kbd.h	/^static uchar normalmap[256] =$/;"	v
nread	pipe.c	/^  uint nread;     \/\/ number of bytes read$/;"	m	struct:pipe	file:
nu	cat.asm	/^    nu = 4096;$/;"	d
nu	echo.asm	/^    nu = 4096;$/;"	d
nu	grep.asm	/^    nu = 4096;$/;"	d
nu	init.asm	/^    nu = 4096;$/;"	d
nu	kill.asm	/^    nu = 4096;$/;"	d
nu	ln.asm	/^    nu = 4096;$/;"	d
nu	ls.asm	/^    nu = 4096;$/;"	d
nu	mkdir.asm	/^    nu = 4096;$/;"	d
nu	rm.asm	/^    nu = 4096;$/;"	d
nu	sh.asm	/^    nu = 4096;$/;"	d
nu	wc.asm	/^    nu = 4096;$/;"	d
nu	zombie.asm	/^    nu = 4096;$/;"	d
nulterminate	sh.c	/^nulterminate(struct cmd *cmd)$/;"	f
num	kernel.asm	/^  num = proc->tf->eax;$/;"	d
nunits	cat.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	echo.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	grep.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	init.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	kill.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ln.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	ls.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	mkdir.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	rm.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	sh.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	wc.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nunits	zombie.asm	/^  nunits = (nbytes + sizeof(Header) - 1)\/sizeof(Header) + 1;$/;"	d
nwrite	pipe.c	/^  uint nwrite;    \/\/ number of bytes written$/;"	m	struct:pipe	file:
oemlength	mp.h	/^  ushort oemlength;             \/\/ OEM table length$/;"	m	struct:mpconf
oemtable	mp.h	/^  uint *oemtable;               \/\/ OEM table pointer$/;"	m	struct:mpconf
oesp	x86.h	/^  uint oesp;      \/\/ useless & ignored$/;"	m	struct:trapframe
off	elf.h	/^  uint off;$/;"	m	struct:proghdr
off	file.h	/^  uint off;$/;"	m	struct:file
off_15_0	mmu.h	/^  uint off_15_0 : 16;   \/\/ low 16 bits of offset in segment$/;"	m	struct:gatedesc
off_31_16	mmu.h	/^  uint off_31_16 : 16;  \/\/ high bits of offset in segment$/;"	m	struct:gatedesc
offset	bootblock.asm	/^  offset = (offset \/ SECTSIZE) + 1;$/;"	d
ofile	proc.h	/^  struct file *ofile[NOFILE];  \/\/ Open files$/;"	m	struct:proc	typeref:struct:proc::file
oldpgdir	kernel.asm	/^  oldpgdir = proc->pgdir;$/;"	d
os	cat.asm	/^  os = s;$/;"	d
os	echo.asm	/^  os = s;$/;"	d
os	grep.asm	/^  os = s;$/;"	d
os	init.asm	/^  os = s;$/;"	d
os	kernel.asm	/^  os = s;$/;"	d
os	kill.asm	/^  os = s;$/;"	d
os	ln.asm	/^  os = s;$/;"	d
os	ls.asm	/^  os = s;$/;"	d
os	mkdir.asm	/^  os = s;$/;"	d
os	rm.asm	/^  os = s;$/;"	d
os	sh.asm	/^  os = s;$/;"	d
os	wc.asm	/^  os = s;$/;"	d
os	zombie.asm	/^  os = s;$/;"	d
outb	x86.h	/^outb(ushort port, uchar data)$/;"	f
outsl	x86.h	/^outsl(int port, const void *addr, int cnt)$/;"	f
outw	x86.h	/^outw(ushort port, ushort data)$/;"	f
p	cat.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	echo.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	grep.asm	/^      p = q+1;$/;"	d
p	grep.asm	/^    p = buf;$/;"	d
p	grep.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	init.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	kernel.asm	/^    p = ((bda[0x14]<<8)|bda[0x13])*1024;$/;"	d
p	kernel.asm	/^  p = (char*)PGROUNDUP((uint)vstart);$/;"	d
p	kernel.asm	/^  p = 0;$/;"	d
p	kernel.asm	/^  p = allocproc();$/;"	d
p	kill.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ln.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	ls.asm	/^    p = buf+strlen(buf);$/;"	d
p	ls.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mkdir.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	mmu.h	/^  uint p : 1;           \/\/ Present$/;"	m	struct:gatedesc
p	mmu.h	/^  uint p : 1;          \/\/ Present$/;"	m	struct:segdesc
p	rm.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	sh.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	wc.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p	zombie.asm	/^  p = sbrk(nu * sizeof(Header));$/;"	d
p2v	memlayout.h	/^static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }$/;"	f
pa	bootblock.asm	/^    pa = (uchar*)ph->paddr;$/;"	d
pa	kernel.asm	/^      pa = PTE_ADDR(*pte);$/;"	d
pa	kernel.asm	/^    pa = PTE_ADDR(*pte);$/;"	d
pa0	kernel.asm	/^    pa0 = uva2ka(pgdir, (char*)va0);$/;"	d
pad	ioapic.c	/^  uint pad[3];$/;"	m	struct:ioapic	file:
padding1	mmu.h	/^  ushort padding1;$/;"	m	struct:taskstate
padding1	x86.h	/^  ushort padding1;$/;"	m	struct:trapframe
padding10	mmu.h	/^  ushort padding10;$/;"	m	struct:taskstate
padding2	mmu.h	/^  ushort padding2;$/;"	m	struct:taskstate
padding2	x86.h	/^  ushort padding2;$/;"	m	struct:trapframe
padding3	mmu.h	/^  ushort padding3;$/;"	m	struct:taskstate
padding3	x86.h	/^  ushort padding3;$/;"	m	struct:trapframe
padding4	mmu.h	/^  ushort padding4;$/;"	m	struct:taskstate
padding4	x86.h	/^  ushort padding4;$/;"	m	struct:trapframe
padding5	mmu.h	/^  ushort padding5;$/;"	m	struct:taskstate
padding5	x86.h	/^  ushort padding5;$/;"	m	struct:trapframe
padding6	mmu.h	/^  ushort padding6;$/;"	m	struct:taskstate
padding6	x86.h	/^  ushort padding6;$/;"	m	struct:trapframe
padding7	mmu.h	/^  ushort padding7;$/;"	m	struct:taskstate
padding8	mmu.h	/^  ushort padding8;$/;"	m	struct:taskstate
padding9	mmu.h	/^  ushort padding9;$/;"	m	struct:taskstate
paddr	elf.h	/^  uint paddr;$/;"	m	struct:proghdr
panic	console.c	/^panic(char *s)$/;"	f
panic	sh.c	/^panic(char *s)$/;"	f
panicked	console.c	/^static int panicked = 0;$/;"	v	file:
panicked	kernel.asm	/^  panicked = 1; \/\/ freeze other CPU$/;"	d
parent	proc.h	/^  struct proc *parent;         \/\/ Parent process$/;"	m	struct:proc	typeref:struct:proc::proc
parseblock	sh.c	/^parseblock(char **ps, char *es)$/;"	f
parsecmd	sh.c	/^parsecmd(char *s)$/;"	f
parseexec	sh.c	/^parseexec(char **ps, char *es)$/;"	f
parseline	sh.c	/^parseline(char **ps, char *es)$/;"	f
parsepipe	sh.c	/^parsepipe(char **ps, char *es)$/;"	f
parseredirs	sh.c	/^parseredirs(struct cmd *cmd, char **ps, char *es)$/;"	f
pattern	grep.asm	/^  pattern = argv[1];$/;"	d
pcmd	sh.asm	/^    pcmd = (struct pipecmd*)cmd;$/;"	d
pcs	spinlock.h	/^  uint pcs[10];      \/\/ The call stack (an array of program counters)$/;"	m	struct:spinlock
pde	kernel.asm	/^  pde = &pgdir[PDX(va)];$/;"	d
pde_t	kernel.asm	/^pde_t entrypgdir[];  \/\/ For entry.S$/;"	l
pde_t	types.h	/^typedef uint pde_t;$/;"	t
peek	sh.c	/^peek(char **ps, char *es, char *toks)$/;"	f
perm	vm.c	/^  int perm;$/;"	m	struct:kmap	file:
pgdir	kernel.asm	/^  pgdir = 0;$/;"	d
pgdir	proc.h	/^  pde_t* pgdir;                \/\/ Page table$/;"	m	struct:proc
pgtab	kernel.asm	/^    pgtab = (pte_t*)p2v(PTE_ADDR(*pde));$/;"	d
ph	bootblock.asm	/^  ph = (struct proghdr*)((uchar*)elf + elf->phoff);$/;"	d
phentsize	elf.h	/^  ushort phentsize;$/;"	m	struct:elfhdr
phnum	elf.h	/^  ushort phnum;$/;"	m	struct:elfhdr
phoff	elf.h	/^  uint phoff;$/;"	m	struct:elfhdr
phys_end	vm.c	/^  uint phys_end;$/;"	m	struct:kmap	file:
phys_start	vm.c	/^  uint phys_start;$/;"	m	struct:kmap	file:
physaddr	mp.h	/^  void *physaddr;               \/\/ phys addr of MP config table$/;"	m	struct:mp
picenable	picirq.c	/^picenable(int irq)$/;"	f
picinit	picirq.c	/^picinit(void)$/;"	f
picsetmask	picirq.c	/^picsetmask(ushort mask)$/;"	f	file:
pid	init.asm	/^    pid = fork();$/;"	d
pid	kernel.asm	/^        pid = p->pid;$/;"	d
pid	kernel.asm	/^  pid = np->pid;$/;"	d
pid	proc.h	/^  volatile int pid;            \/\/ Process ID$/;"	m	struct:proc
pid	sh.asm	/^  pid = fork();$/;"	d
pinit	proc.c	/^pinit(void)$/;"	f
pipe	file.h	/^  struct pipe *pipe;$/;"	m	struct:file	typeref:struct:file::pipe
pipe	pipe.c	/^struct pipe {$/;"	s	file:
pipealloc	pipe.c	/^pipealloc(struct file **f0, struct file **f1)$/;"	f
pipeclose	pipe.c	/^pipeclose(struct pipe *p, int writable)$/;"	f
pipecmd	sh.c	/^pipecmd(struct cmd *left, struct cmd *right)$/;"	f
pipecmd	sh.c	/^struct pipecmd {$/;"	s	file:
piperead	pipe.c	/^piperead(struct pipe *p, char *addr, int n)$/;"	f
pipewrite	pipe.c	/^pipewrite(struct pipe *p, char *addr, int n)$/;"	f
popcli	spinlock.c	/^popcli(void)$/;"	f
pos	kernel.asm	/^  pos = inb(CRTPORT+1) << 8;$/;"	d
prev	buf.h	/^  struct buf *prev; \/\/ LRU cache list$/;"	m	struct:buf	typeref:struct:buf::buf
printf	printf.c	/^printf(int fd, char *fmt, ...)$/;"	f
printint	console.c	/^printint(int xx, int base, int sign)$/;"	f	file:
printint	printf.c	/^printint(int fd, int xx, int base, int sgn)$/;"	f	file:
proc	kernel.asm	/^      proc = (struct mpproc*)p;$/;"	d
proc	kernel.asm	/^      proc = 0;$/;"	d
proc	kernel.asm	/^      proc = p;$/;"	d
proc	kernel.asm	/^  proc = 0;$/;"	d
proc	proc.c	/^  struct proc proc[NPROC];$/;"	m	struct:__anon8	typeref:struct:__anon8::proc	file:
proc	proc.h	/^  struct proc *proc;           \/\/ The currently-running process.$/;"	m	struct:cpu	typeref:struct:cpu::proc
proc	proc.h	/^struct proc {$/;"	s
procdump	proc.c	/^procdump(void)$/;"	f
procstate	proc.h	/^enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };$/;"	g
product	mp.h	/^  uchar product[20];            \/\/ product id$/;"	m	struct:mpconf
proghdr	elf.h	/^struct proghdr {$/;"	s
ptable	proc.c	/^} ptable;$/;"	v	typeref:struct:__anon8
pte	kernel.asm	/^    pte = walkpgdir(pgdir, (char*)a, 0);$/;"	d
pte	kernel.asm	/^  pte = walkpgdir(pgdir, uva, 0);$/;"	d
pte_t	mmu.h	/^typedef uint pte_t;$/;"	t
ptr	umalloc.c	/^    union header *ptr;$/;"	m	struct:header::__anon9	typeref:union:header::__anon9::header	file:
pushcli	spinlock.c	/^pushcli(void)$/;"	f
putc	printf.c	/^putc(int fd, char c)$/;"	f	file:
qnext	buf.h	/^  struct buf *qnext; \/\/ disk queue$/;"	m	struct:buf	typeref:struct:buf::buf
r	cat.asm	/^  r = fstat(fd, st);$/;"	d
r	console.c	/^  uint r;  \/\/ Read index$/;"	m	struct:__anon3	file:
r	echo.asm	/^  r = fstat(fd, st);$/;"	d
r	grep.asm	/^  r = fstat(fd, st);$/;"	d
r	init.asm	/^  r = fstat(fd, st);$/;"	d
r	kernel.asm	/^  r = (struct run*)v;$/;"	d
r	kernel.asm	/^  r = kmem.freelist;$/;"	d
r	kill.asm	/^  r = fstat(fd, st);$/;"	d
r	ln.asm	/^  r = fstat(fd, st);$/;"	d
r	ls.asm	/^  r = fstat(fd, st);$/;"	d
r	mkdir.asm	/^  r = fstat(fd, st);$/;"	d
r	rm.asm	/^  r = fstat(fd, st);$/;"	d
r	sh.asm	/^  r = fstat(fd, st);$/;"	d
r	wc.asm	/^  r = fstat(fd, st);$/;"	d
r	zombie.asm	/^  r = fstat(fd, st);$/;"	d
rcmd	sh.asm	/^    rcmd = (struct redircmd*)cmd;$/;"	d
rcr2	x86.h	/^rcr2(void)$/;"	f
read	file.h	/^  int (*read)(struct inode*, char*, int);$/;"	m	struct:devsw
read_head	log.c	/^read_head(void)$/;"	f	file:
readable	file.h	/^  char readable;$/;"	m	struct:file
readeflags	x86.h	/^readeflags(void)$/;"	f
readi	fs.c	/^readi(struct inode *ip, char *dst, uint off, uint n)$/;"	f
readopen	pipe.c	/^  int readopen;   \/\/ read fd is still open$/;"	m	struct:pipe	file:
readsb	fs.c	/^readsb(int dev, struct superblock *sb)$/;"	f
readsect	bootmain.c	/^readsect(void *dst, uint offset)$/;"	f
readseg	bootmain.c	/^readseg(uchar* pa, uint count, uint offset)$/;"	f
recover_from_log	log.c	/^recover_from_log(void)$/;"	f	file:
redircmd	sh.c	/^redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)$/;"	f
redircmd	sh.c	/^struct redircmd {$/;"	s	file:
ref	file.h	/^  int ref;            \/\/ Reference count$/;"	m	struct:inode
ref	file.h	/^  int ref; \/\/ reference count$/;"	m	struct:file
reg	ioapic.c	/^  uint reg;$/;"	m	struct:ioapic	file:
register_handler	proc.c	/^register_handler(sighandler_t sighandler)$/;"	f
release	spinlock.c	/^release(struct spinlock *lk)$/;"	f
reserved	mp.h	/^  uchar reserved;$/;"	m	struct:mpconf
reserved	mp.h	/^  uchar reserved[3];$/;"	m	struct:mp
reserved	mp.h	/^  uchar reserved[8];$/;"	m	struct:mpproc
ret	sh.asm	/^      ret = '+';$/;"	d
ret	sh.asm	/^    ret = 'a';$/;"	d
ret	sh.asm	/^    ret = parseredirs(ret, ps, es);$/;"	d
ret	sh.asm	/^  ret = *s;$/;"	d
ret	sh.asm	/^  ret = execcmd();$/;"	d
ret	sh.asm	/^  ret = parseredirs(ret, ps, es);$/;"	d
return	kernel.asm	/^  return d;$/;"	d
right	sh.c	/^  struct cmd *right;$/;"	m	struct:listcmd	typeref:struct:listcmd::cmd	file:
right	sh.c	/^  struct cmd *right;$/;"	m	struct:pipecmd	typeref:struct:pipecmd::cmd	file:
rinode	mkfs.c	/^rinode(uint inum, struct dinode *ip)$/;"	f
rsect	mkfs.c	/^rsect(uint sec, void *buf)$/;"	f
rsv1	mmu.h	/^  uint rsv1 : 1;       \/\/ Reserved$/;"	m	struct:segdesc
rsv1	mmu.h	/^  uint rsv1 : 3;        \/\/ reserved(should be zero I guess)$/;"	m	struct:gatedesc
run	kalloc.c	/^struct run {$/;"	s	file:
runcmd	sh.c	/^runcmd(struct cmd *cmd)$/;"	f
s	cat.asm	/^          s = "(null)";$/;"	d
s	cat.asm	/^        s = (char*)*ap;$/;"	d
s	echo.asm	/^          s = "(null)";$/;"	d
s	echo.asm	/^        s = (char*)*ap;$/;"	d
s	grep.asm	/^          s = "(null)";$/;"	d
s	grep.asm	/^        s = (char*)*ap;$/;"	d
s	init.asm	/^          s = "(null)";$/;"	d
s	init.asm	/^        s = (char*)*ap;$/;"	d
s	kernel.asm	/^        s = "(null)";$/;"	d
s	kernel.asm	/^  s = path;$/;"	d
s	kernel.asm	/^  s = src;$/;"	d
s	kill.asm	/^          s = "(null)";$/;"	d
s	kill.asm	/^        s = (char*)*ap;$/;"	d
s	ln.asm	/^          s = "(null)";$/;"	d
s	ln.asm	/^        s = (char*)*ap;$/;"	d
s	ls.asm	/^          s = "(null)";$/;"	d
s	ls.asm	/^        s = (char*)*ap;$/;"	d
s	mkdir.asm	/^          s = "(null)";$/;"	d
s	mkdir.asm	/^        s = (char*)*ap;$/;"	d
s	mmu.h	/^  uint s : 1;           \/\/ must be 0 (system)$/;"	m	struct:gatedesc
s	mmu.h	/^  uint s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:segdesc
s	rm.asm	/^          s = "(null)";$/;"	d
s	rm.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^          s = "(null)";$/;"	d
s	sh.asm	/^        s = (char*)*ap;$/;"	d
s	sh.asm	/^  s = *ps;$/;"	d
s	umalloc.c	/^  } s;$/;"	m	union:header	typeref:struct:header::__anon9	file:
s	wc.asm	/^          s = "(null)";$/;"	d
s	wc.asm	/^        s = (char*)*ap;$/;"	d
s	zombie.asm	/^          s = "(null)";$/;"	d
s	zombie.asm	/^        s = (char*)*ap;$/;"	d
s1	kernel.asm	/^  s1 = v1;$/;"	d
s2	kernel.asm	/^  s2 = v2;$/;"	d
safestrcpy	string.c	/^safestrcpy(char *s, const char *t, int n)$/;"	f
sb	mkfs.c	/^struct superblock sb;$/;"	v	typeref:struct:superblock
sched	proc.c	/^sched(void)$/;"	f
scheduler	proc.c	/^scheduler(void)$/;"	f
scheduler	proc.h	/^  struct context *scheduler;   \/\/ swtch() here to enter scheduler$/;"	m	struct:cpu	typeref:struct:cpu::context
sector	buf.h	/^  uint sector;$/;"	m	struct:buf
sector	log.c	/^  int sector[LOGSIZE];$/;"	m	struct:logheader	file:
segdesc	mmu.h	/^struct segdesc {$/;"	s
seginit	vm.c	/^seginit(void)$/;"	f
setupkvm	vm.c	/^setupkvm()$/;"	f
shentsize	elf.h	/^  ushort shentsize;$/;"	m	struct:elfhdr
shiftcode	kbd.h	/^static uchar shiftcode[256] =$/;"	v
shiftmap	kbd.h	/^static uchar shiftmap[256] =$/;"	v
shnum	elf.h	/^  ushort shnum;$/;"	m	struct:elfhdr
shoff	elf.h	/^  uint shoff;$/;"	m	struct:elfhdr
shstrndx	elf.h	/^  ushort shstrndx;$/;"	m	struct:elfhdr
sighandler_t	signal.h	/^typedef void (*sighandler_t)(void);/;"	t
signature	mp.h	/^  uchar signature[4];           \/\/ "PCMP"$/;"	m	struct:mpconf
signature	mp.h	/^  uchar signature[4];           \/\/ "_MP_"$/;"	m	struct:mp
signature	mp.h	/^  uchar signature[4];           \/\/ CPU signature$/;"	m	struct:mpproc
size	file.h	/^  uint size;$/;"	m	struct:inode
size	fs.h	/^  uint size;            \/\/ Size of file (bytes)$/;"	m	struct:dinode
size	fs.h	/^  uint size;         \/\/ Size of file system image (blocks)$/;"	m	struct:superblock
size	log.c	/^  int size;$/;"	m	struct:log	file:
size	mkfs.c	/^int size = 4096;$/;"	v
size	stat.h	/^  uint size;   \/\/ Size of file in bytes$/;"	m	struct:stat
size	umalloc.c	/^    uint size;$/;"	m	struct:header::__anon9	file:
skipelem	fs.c	/^skipelem(char *path, char *name)$/;"	f	file:
sleep	proc.c	/^sleep(void *chan, struct spinlock *lk)$/;"	f
sp	kernel.asm	/^    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;$/;"	d
sp	kernel.asm	/^  sp = p->kstack + KSTACKSIZE;$/;"	d
sp	kernel.asm	/^  sp = sz;$/;"	d
specrev	mp.h	/^  uchar specrev;                \/\/ [14]$/;"	m	struct:mp
spin	bootasm.S	/^spin:$/;"	l
spin	bootblock.asm	/^spin:$/;"	l
spin	entryother.S	/^spin:$/;"	l
spin	entryother.asm	/^spin:$/;"	l
spinlock	spinlock.h	/^struct spinlock {$/;"	s
src	cat.asm	/^  src = vsrc;$/;"	d
src	echo.asm	/^  src = vsrc;$/;"	d
src	grep.asm	/^  src = vsrc;$/;"	d
src	init.asm	/^  src = vsrc;$/;"	d
src	kill.asm	/^  src = vsrc;$/;"	d
src	ln.asm	/^  src = vsrc;$/;"	d
src	ls.asm	/^  src = vsrc;$/;"	d
src	mkdir.asm	/^  src = vsrc;$/;"	d
src	rm.asm	/^  src = vsrc;$/;"	d
src	sh.asm	/^  src = vsrc;$/;"	d
src	wc.asm	/^  src = vsrc;$/;"	d
src	zombie.asm	/^  src = vsrc;$/;"	d
ss	mmu.h	/^  ushort ss;$/;"	m	struct:taskstate
ss	x86.h	/^  ushort ss;$/;"	m	struct:trapframe
ss0	mmu.h	/^  ushort ss0;        \/\/   after an increase in privilege level$/;"	m	struct:taskstate
ss1	mmu.h	/^  ushort ss1;$/;"	m	struct:taskstate
ss2	mmu.h	/^  ushort ss2;$/;"	m	struct:taskstate
st	kernel.asm	/^  st = inb(KBSTATP);$/;"	d
stack	kernel.asm	/^    stack = kalloc();$/;"	d
stack	uthread.h	/^	char		   *stack;	    \/* the thread's stack *\/$/;"	m	struct:uthread
start	bootasm.S	/^start:$/;"	l
start	bootblock.asm	/^start:$/;"	l
start	entryother.S	/^start:$/;"	l
start	entryother.asm	/^start:$/;"	l
start	initcode.S	/^start:$/;"	l
start	initcode.asm	/^start:$/;"	l
start	log.c	/^  int start;$/;"	m	struct:log	file:
start32	bootasm.S	/^start32:$/;"	l
start32	bootblock.asm	/^start32:$/;"	l
start32	entryother.S	/^start32:$/;"	l
start32	entryother.asm	/^start32:$/;"	l
started	proc.h	/^  volatile uint started;        \/\/ Has the CPU started?$/;"	m	struct:cpu
startothers	main.c	/^startothers(void)$/;"	f	file:
stat	mkfs.c	8;"	d	file:
stat	stat.h	/^struct stat {$/;"	s
stat	ulib.c	/^stat(char *n, struct stat *st)$/;"	f
state	cat.asm	/^        state = '%';$/;"	d
state	cat.asm	/^      state = 0;$/;"	d
state	cat.asm	/^  state = 0;$/;"	d
state	echo.asm	/^        state = '%';$/;"	d
state	echo.asm	/^      state = 0;$/;"	d
state	echo.asm	/^  state = 0;$/;"	d
state	grep.asm	/^        state = '%';$/;"	d
state	grep.asm	/^      state = 0;$/;"	d
state	grep.asm	/^  state = 0;$/;"	d
state	init.asm	/^        state = '%';$/;"	d
state	init.asm	/^      state = 0;$/;"	d
state	init.asm	/^  state = 0;$/;"	d
state	kernel.asm	/^      state = "???";$/;"	d
state	kernel.asm	/^      state = states[p->state];$/;"	d
state	kill.asm	/^        state = '%';$/;"	d
state	kill.asm	/^      state = 0;$/;"	d
state	kill.asm	/^  state = 0;$/;"	d
state	ln.asm	/^        state = '%';$/;"	d
state	ln.asm	/^      state = 0;$/;"	d
state	ln.asm	/^  state = 0;$/;"	d
state	ls.asm	/^        state = '%';$/;"	d
state	ls.asm	/^      state = 0;$/;"	d
state	ls.asm	/^  state = 0;$/;"	d
state	mkdir.asm	/^        state = '%';$/;"	d
state	mkdir.asm	/^      state = 0;$/;"	d
state	mkdir.asm	/^  state = 0;$/;"	d
state	proc.h	/^  enum procstate state;        \/\/ Process state$/;"	m	struct:proc	typeref:enum:proc::procstate
state	rm.asm	/^        state = '%';$/;"	d
state	rm.asm	/^      state = 0;$/;"	d
state	rm.asm	/^  state = 0;$/;"	d
state	sh.asm	/^        state = '%';$/;"	d
state	sh.asm	/^      state = 0;$/;"	d
state	sh.asm	/^  state = 0;$/;"	d
state	uthread.h	/^	uthread_state   state;     	\/* running, runnable, sleeping *\/$/;"	m	struct:uthread
state	wc.asm	/^        state = '%';$/;"	d
state	wc.asm	/^      state = 0;$/;"	d
state	wc.asm	/^  state = 0;$/;"	d
state	zombie.asm	/^        state = '%';$/;"	d
state	zombie.asm	/^      state = 0;$/;"	d
state	zombie.asm	/^  state = 0;$/;"	d
stati	fs.c	/^stati(struct inode *ip, struct stat *st)$/;"	f
static	bootblock.asm	/^static inline uchar$/;"	l
static	bootblock.asm	/^static inline void$/;"	l
static	cat.asm	/^static Header *freep;$/;"	l
static	cat.asm	/^static Header base;$/;"	l
static	cat.asm	/^static Header*$/;"	l
static	cat.asm	/^static inline void$/;"	l
static	cat.asm	/^static void$/;"	l
static	echo.asm	/^static Header *freep;$/;"	l
static	echo.asm	/^static Header base;$/;"	l
static	echo.asm	/^static Header*$/;"	l
static	echo.asm	/^static inline void$/;"	l
static	echo.asm	/^static void$/;"	l
static	grep.asm	/^static Header *freep;$/;"	l
static	grep.asm	/^static Header base;$/;"	l
static	grep.asm	/^static Header*$/;"	l
static	grep.asm	/^static inline void$/;"	l
static	grep.asm	/^static void$/;"	l
static	init.asm	/^static Header *freep;$/;"	l
static	init.asm	/^static Header base;$/;"	l
static	init.asm	/^static Header*$/;"	l
static	init.asm	/^static inline void$/;"	l
static	init.asm	/^static void$/;"	l
static	kernel.asm	/^static char*$/;"	l
static	kernel.asm	/^static inline uchar$/;"	l
static	kernel.asm	/^static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }$/;"	l
static	kernel.asm	/^static inline uint$/;"	l
static	kernel.asm	/^static inline void *p2v(uint a) { return (void *) ((a) + KERNBASE); }$/;"	l
static	kernel.asm	/^static inline void$/;"	l
static	kernel.asm	/^static int uart;    \/\/ is there a uart?$/;"	l
static	kernel.asm	/^static int$/;"	l
static	kernel.asm	/^static pte_t *$/;"	l
static	kernel.asm	/^static struct buf*$/;"	t
static	kernel.asm	/^static struct inode*$/;"	t
static	kernel.asm	/^static struct mp*$/;"	t
static	kernel.asm	/^static struct mpconf*$/;"	t
static	kernel.asm	/^static struct proc*$/;"	t
static	kernel.asm	/^static uchar$/;"	l
static	kernel.asm	/^static uint$/;"	l
static	kernel.asm	/^static ushort *crt = (ushort*)P2V(0xb8000);  \/\/ CGA memory$/;"	l
static	kernel.asm	/^static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);$/;"	l
static	kernel.asm	/^static void $/;"	l
static	kernel.asm	/^static void idestart(struct buf*);$/;"	l
static	kernel.asm	/^static void itrunc(struct inode*);$/;"	l
static	kernel.asm	/^static void recover_from_log(void);$/;"	l
static	kernel.asm	/^static void wakeup1(void *chan);$/;"	l
static	kernel.asm	/^static void$/;"	l
static	kill.asm	/^static Header *freep;$/;"	l
static	kill.asm	/^static Header base;$/;"	l
static	kill.asm	/^static Header*$/;"	l
static	kill.asm	/^static inline void$/;"	l
static	kill.asm	/^static void$/;"	l
static	ln.asm	/^static Header *freep;$/;"	l
static	ln.asm	/^static Header base;$/;"	l
static	ln.asm	/^static Header*$/;"	l
static	ln.asm	/^static inline void$/;"	l
static	ln.asm	/^static void$/;"	l
static	ls.asm	/^static Header *freep;$/;"	l
static	ls.asm	/^static Header base;$/;"	l
static	ls.asm	/^static Header*$/;"	l
static	ls.asm	/^static inline void$/;"	l
static	ls.asm	/^static void$/;"	l
static	mkdir.asm	/^static Header *freep;$/;"	l
static	mkdir.asm	/^static Header base;$/;"	l
static	mkdir.asm	/^static Header*$/;"	l
static	mkdir.asm	/^static inline void$/;"	l
static	mkdir.asm	/^static void$/;"	l
static	rm.asm	/^static Header *freep;$/;"	l
static	rm.asm	/^static Header base;$/;"	l
static	rm.asm	/^static Header*$/;"	l
static	rm.asm	/^static inline void$/;"	l
static	rm.asm	/^static void$/;"	l
static	sh.asm	/^static Header *freep;$/;"	l
static	sh.asm	/^static Header base;$/;"	l
static	sh.asm	/^static Header*$/;"	l
static	sh.asm	/^static inline void$/;"	l
static	sh.asm	/^static void$/;"	l
static	wc.asm	/^static Header *freep;$/;"	l
static	wc.asm	/^static Header base;$/;"	l
static	wc.asm	/^static Header*$/;"	l
static	wc.asm	/^static inline void$/;"	l
static	wc.asm	/^static void$/;"	l
static	zombie.asm	/^static Header *freep;$/;"	l
static	zombie.asm	/^static Header base;$/;"	l
static	zombie.asm	/^static Header*$/;"	l
static	zombie.asm	/^static inline void$/;"	l
static	zombie.asm	/^static void$/;"	l
sti	x86.h	/^sti(void)$/;"	f
stosb	x86.h	/^stosb(void *addr, int data, int cnt)$/;"	f
stosl	x86.h	/^stosl(void *addr, int data, int cnt)$/;"	f
strchr	ulib.c	/^strchr(const char *s, char c)$/;"	f
strcmp	ulib.c	/^strcmp(const char *p, const char *q)$/;"	f
strcpy	ulib.c	/^strcpy(char *s, char *t)$/;"	f
strlen	string.c	/^strlen(const char *s)$/;"	f
strlen	ulib.c	/^strlen(char *s)$/;"	f
strncmp	string.c	/^strncmp(const char *p, const char *q, uint n)$/;"	f
strncpy	string.c	/^strncpy(char *s, const char *t, int n)$/;"	f
struct	kernel.asm	/^  struct proc *np;$/;"	l
struct	kernel.asm	/^  struct proc *p;$/;"	l
sum	kernel.asm	/^  sum = 0;$/;"	d
sum	mp.c	/^sum(uchar *addr, int len)$/;"	f	file:
superblock	fs.h	/^struct superblock {$/;"	s
switchkvm	vm.c	/^switchkvm(void)$/;"	f
switchuvm	vm.c	/^switchuvm(struct proc *p)$/;"	f
swtch	kernel.asm	/^swtch:$/;"	l
swtch	swtch.S	/^swtch:$/;"	l
symbols	sh.c	/^char symbols[] = "<|>&;()";$/;"	v
sys_chdir	sysfile.c	/^sys_chdir(void)$/;"	f
sys_close	sysfile.c	/^sys_close(void)$/;"	f
sys_dup	sysfile.c	/^sys_dup(void)$/;"	f
sys_exec	sysfile.c	/^sys_exec(void)$/;"	f
sys_exit	sysproc.c	/^sys_exit(void)$/;"	f
sys_fork	sysproc.c	/^sys_fork(void)$/;"	f
sys_fstat	sysfile.c	/^sys_fstat(void)$/;"	f
sys_getpid	sysproc.c	/^sys_getpid(void)$/;"	f
sys_kill	sysproc.c	/^sys_kill(void)$/;"	f
sys_link	sysfile.c	/^sys_link(void)$/;"	f
sys_mkdir	sysfile.c	/^sys_mkdir(void)$/;"	f
sys_mknod	sysfile.c	/^sys_mknod(void)$/;"	f
sys_open	sysfile.c	/^sys_open(void)$/;"	f
sys_pipe	sysfile.c	/^sys_pipe(void)$/;"	f
sys_read	sysfile.c	/^sys_read(void)$/;"	f
sys_sbrk	sysproc.c	/^sys_sbrk(void)$/;"	f
sys_sleep	sysproc.c	/^sys_sleep(void)$/;"	f
sys_unlink	sysfile.c	/^sys_unlink(void)$/;"	f
sys_uptime	sysproc.c	/^sys_uptime(void)$/;"	f
sys_wait	sysproc.c	/^sys_wait(void)$/;"	f
sys_write	sysfile.c	/^sys_write(void)$/;"	f
syscall	syscall.c	/^syscall(void)$/;"	f
syscalls	syscall.c	/^static int (*syscalls[])(void) = {$/;"	v	file:
sz	kernel.asm	/^  sz = 0;$/;"	d
sz	kernel.asm	/^  sz = PGROUNDUP(sz);$/;"	d
sz	kernel.asm	/^  sz = proc->sz;$/;"	d
sz	proc.h	/^  uint sz;                     \/\/ Size of process memory (bytes)$/;"	m	struct:proc
t	mmu.h	/^  ushort t;          \/\/ Trap on task switch$/;"	m	struct:taskstate
target	kernel.asm	/^  target = n;$/;"	d
taskstate	mmu.h	/^struct taskstate {$/;"	s
tf	proc.h	/^  struct trapframe *tf;        \/\/ Trap frame for current syscall$/;"	m	struct:proc	typeref:struct:proc::trapframe
ticks	trap.c	/^uint ticks;$/;"	v
ticks0	kernel.asm	/^  ticks0 = ticks;$/;"	d
tickslock	trap.c	/^struct spinlock tickslock;$/;"	v	typeref:struct:spinlock
tid	uthread.h	/^	int				tid;$/;"	m	struct:uthread
timerinit	timer.c	/^timerinit(void)$/;"	f
togglecode	kbd.h	/^static uchar togglecode[256] =$/;"	v
tok	sh.asm	/^    tok = gettoken(ps, es, 0, 0);$/;"	d
trap	trap.c	/^trap(struct trapframe *tf)$/;"	f
trapframe	x86.h	/^struct trapframe {$/;"	s
trapno	x86.h	/^  uint trapno;$/;"	m	struct:trapframe
trapret	kernel.asm	/^trapret:$/;"	l
trapret	trapasm.S	/^trapret:$/;"	l
ts	proc.h	/^  struct taskstate ts;         \/\/ Used by x86 to find stack for interrupt$/;"	m	struct:cpu	typeref:struct:cpu::taskstate
tvinit	trap.c	/^tvinit(void)$/;"	f
type	elf.h	/^  uint type;$/;"	m	struct:proghdr
type	elf.h	/^  ushort type;$/;"	m	struct:elfhdr
type	file.h	/^  enum { FD_NONE, FD_PIPE, FD_INODE } type;$/;"	m	struct:file	typeref:enum:file::__anon5
type	file.h	/^  short type;         \/\/ copy of disk inode$/;"	m	struct:inode
type	fs.h	/^  short type;           \/\/ File type$/;"	m	struct:dinode
type	mmu.h	/^  uint type : 4;        \/\/ type(STS_{TG,IG32,TG32})$/;"	m	struct:gatedesc
type	mmu.h	/^  uint type : 4;       \/\/ Segment type (see STS_ constants)$/;"	m	struct:segdesc
type	mp.h	/^  uchar type;                   \/\/ MP system config type$/;"	m	struct:mp
type	mp.h	/^  uchar type;                   \/\/ entry type (0)$/;"	m	struct:mpproc
type	mp.h	/^  uchar type;                   \/\/ entry type (2)$/;"	m	struct:mpioapic
type	sh.c	/^  int type;$/;"	m	struct:backcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:cmd	file:
type	sh.c	/^  int type;$/;"	m	struct:execcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:listcmd	file:
type	sh.c	/^  int type;$/;"	m	struct:pipecmd	file:
type	sh.c	/^  int type;$/;"	m	struct:redircmd	file:
type	stat.h	/^  short type;  \/\/ Type of file$/;"	m	struct:stat
uart	kernel.asm	/^  uart = 1;$/;"	d
uart	uart.c	/^static int uart;    \/\/ is there a uart?$/;"	v	file:
uartgetc	uart.c	/^uartgetc(void)$/;"	f	file:
uartinit	uart.c	/^uartinit(void)$/;"	f
uartintr	uart.c	/^uartintr(void)$/;"	f
uartputc	uart.c	/^uartputc(int c)$/;"	f
uchar	kernel.asm	/^uchar ioapicid;$/;"	l
uchar	types.h	/^typedef unsigned char  uchar;$/;"	t
uint	cat.asm	/^uint$/;"	l
uint	echo.asm	/^uint$/;"	l
uint	grep.asm	/^uint$/;"	l
uint	init.asm	/^uint$/;"	l
uint	kernel.asm	/^uint ticks;$/;"	l
uint	kill.asm	/^uint$/;"	l
uint	ln.asm	/^uint$/;"	l
uint	ls.asm	/^uint$/;"	l
uint	mkdir.asm	/^uint$/;"	l
uint	rm.asm	/^uint$/;"	l
uint	sh.asm	/^uint$/;"	l
uint	types.h	/^typedef unsigned int   uint;$/;"	t
uint	wc.asm	/^uint$/;"	l
uint	zombie.asm	/^uint$/;"	l
use_lock	kalloc.c	/^  int use_lock;$/;"	m	struct:__anon7	file:
usedblocks	mkfs.c	/^uint usedblocks;$/;"	v
userinit	proc.c	/^userinit(void)$/;"	f
ushort	types.h	/^typedef unsigned short ushort;$/;"	t
uthread	uthread.h	/^struct uthread {$/;"	s
uthread_p	uthread.h	/^typedef struct uthread uthread_t, *uthread_p;$/;"	t	typeref:struct:
uthread_state	uthread.h	/^typedef enum  {T_FREE, T_RUNNING, T_RUNNABLE, T_SLEEPING} uthread_state;$/;"	t	typeref:enum:__anon10
uthread_t	uthread.h	/^typedef struct uthread uthread_t, *uthread_p;$/;"	t	typeref:struct:uthread
uva2ka	vm.c	/^uva2ka(pde_t *pgdir, char *uva)$/;"	f
v2p	memlayout.h	/^static inline uint v2p(void *a) { return ((uint) (a))  - KERNBASE; }$/;"	f
va	kernel.asm	/^    va = va0 + PGSIZE;$/;"	d
va0	kernel.asm	/^    va0 = (uint)PGROUNDDOWN(va);$/;"	d
vaddr	elf.h	/^  uint vaddr;$/;"	m	struct:proghdr
vector0	kernel.asm	/^vector0:$/;"	l
vector0	vectors.S	/^vector0:$/;"	l
vector1	kernel.asm	/^vector1:$/;"	l
vector1	vectors.S	/^vector1:$/;"	l
vector10	kernel.asm	/^vector10:$/;"	l
vector10	vectors.S	/^vector10:$/;"	l
vector100	kernel.asm	/^vector100:$/;"	l
vector100	vectors.S	/^vector100:$/;"	l
vector101	kernel.asm	/^vector101:$/;"	l
vector101	vectors.S	/^vector101:$/;"	l
vector102	kernel.asm	/^vector102:$/;"	l
vector102	vectors.S	/^vector102:$/;"	l
vector103	kernel.asm	/^vector103:$/;"	l
vector103	vectors.S	/^vector103:$/;"	l
vector104	kernel.asm	/^vector104:$/;"	l
vector104	vectors.S	/^vector104:$/;"	l
vector105	kernel.asm	/^vector105:$/;"	l
vector105	vectors.S	/^vector105:$/;"	l
vector106	kernel.asm	/^vector106:$/;"	l
vector106	vectors.S	/^vector106:$/;"	l
vector107	kernel.asm	/^vector107:$/;"	l
vector107	vectors.S	/^vector107:$/;"	l
vector108	kernel.asm	/^vector108:$/;"	l
vector108	vectors.S	/^vector108:$/;"	l
vector109	kernel.asm	/^vector109:$/;"	l
vector109	vectors.S	/^vector109:$/;"	l
vector11	kernel.asm	/^vector11:$/;"	l
vector11	vectors.S	/^vector11:$/;"	l
vector110	kernel.asm	/^vector110:$/;"	l
vector110	vectors.S	/^vector110:$/;"	l
vector111	kernel.asm	/^vector111:$/;"	l
vector111	vectors.S	/^vector111:$/;"	l
vector112	kernel.asm	/^vector112:$/;"	l
vector112	vectors.S	/^vector112:$/;"	l
vector113	kernel.asm	/^vector113:$/;"	l
vector113	vectors.S	/^vector113:$/;"	l
vector114	kernel.asm	/^vector114:$/;"	l
vector114	vectors.S	/^vector114:$/;"	l
vector115	kernel.asm	/^vector115:$/;"	l
vector115	vectors.S	/^vector115:$/;"	l
vector116	kernel.asm	/^vector116:$/;"	l
vector116	vectors.S	/^vector116:$/;"	l
vector117	kernel.asm	/^vector117:$/;"	l
vector117	vectors.S	/^vector117:$/;"	l
vector118	kernel.asm	/^vector118:$/;"	l
vector118	vectors.S	/^vector118:$/;"	l
vector119	kernel.asm	/^vector119:$/;"	l
vector119	vectors.S	/^vector119:$/;"	l
vector12	kernel.asm	/^vector12:$/;"	l
vector12	vectors.S	/^vector12:$/;"	l
vector120	kernel.asm	/^vector120:$/;"	l
vector120	vectors.S	/^vector120:$/;"	l
vector121	kernel.asm	/^vector121:$/;"	l
vector121	vectors.S	/^vector121:$/;"	l
vector122	kernel.asm	/^vector122:$/;"	l
vector122	vectors.S	/^vector122:$/;"	l
vector123	kernel.asm	/^vector123:$/;"	l
vector123	vectors.S	/^vector123:$/;"	l
vector124	kernel.asm	/^vector124:$/;"	l
vector124	vectors.S	/^vector124:$/;"	l
vector125	kernel.asm	/^vector125:$/;"	l
vector125	vectors.S	/^vector125:$/;"	l
vector126	kernel.asm	/^vector126:$/;"	l
vector126	vectors.S	/^vector126:$/;"	l
vector127	kernel.asm	/^vector127:$/;"	l
vector127	vectors.S	/^vector127:$/;"	l
vector128	kernel.asm	/^vector128:$/;"	l
vector128	vectors.S	/^vector128:$/;"	l
vector129	kernel.asm	/^vector129:$/;"	l
vector129	vectors.S	/^vector129:$/;"	l
vector13	kernel.asm	/^vector13:$/;"	l
vector13	vectors.S	/^vector13:$/;"	l
vector130	kernel.asm	/^vector130:$/;"	l
vector130	vectors.S	/^vector130:$/;"	l
vector131	kernel.asm	/^vector131:$/;"	l
vector131	vectors.S	/^vector131:$/;"	l
vector132	kernel.asm	/^vector132:$/;"	l
vector132	vectors.S	/^vector132:$/;"	l
vector133	kernel.asm	/^vector133:$/;"	l
vector133	vectors.S	/^vector133:$/;"	l
vector134	kernel.asm	/^vector134:$/;"	l
vector134	vectors.S	/^vector134:$/;"	l
vector135	kernel.asm	/^vector135:$/;"	l
vector135	vectors.S	/^vector135:$/;"	l
vector136	kernel.asm	/^vector136:$/;"	l
vector136	vectors.S	/^vector136:$/;"	l
vector137	kernel.asm	/^vector137:$/;"	l
vector137	vectors.S	/^vector137:$/;"	l
vector138	kernel.asm	/^vector138:$/;"	l
vector138	vectors.S	/^vector138:$/;"	l
vector139	kernel.asm	/^vector139:$/;"	l
vector139	vectors.S	/^vector139:$/;"	l
vector14	kernel.asm	/^vector14:$/;"	l
vector14	vectors.S	/^vector14:$/;"	l
vector140	kernel.asm	/^vector140:$/;"	l
vector140	vectors.S	/^vector140:$/;"	l
vector141	kernel.asm	/^vector141:$/;"	l
vector141	vectors.S	/^vector141:$/;"	l
vector142	kernel.asm	/^vector142:$/;"	l
vector142	vectors.S	/^vector142:$/;"	l
vector143	kernel.asm	/^vector143:$/;"	l
vector143	vectors.S	/^vector143:$/;"	l
vector144	kernel.asm	/^vector144:$/;"	l
vector144	vectors.S	/^vector144:$/;"	l
vector145	kernel.asm	/^vector145:$/;"	l
vector145	vectors.S	/^vector145:$/;"	l
vector146	kernel.asm	/^vector146:$/;"	l
vector146	vectors.S	/^vector146:$/;"	l
vector147	kernel.asm	/^vector147:$/;"	l
vector147	vectors.S	/^vector147:$/;"	l
vector148	kernel.asm	/^vector148:$/;"	l
vector148	vectors.S	/^vector148:$/;"	l
vector149	kernel.asm	/^vector149:$/;"	l
vector149	vectors.S	/^vector149:$/;"	l
vector15	kernel.asm	/^vector15:$/;"	l
vector15	vectors.S	/^vector15:$/;"	l
vector150	kernel.asm	/^vector150:$/;"	l
vector150	vectors.S	/^vector150:$/;"	l
vector151	kernel.asm	/^vector151:$/;"	l
vector151	vectors.S	/^vector151:$/;"	l
vector152	kernel.asm	/^vector152:$/;"	l
vector152	vectors.S	/^vector152:$/;"	l
vector153	kernel.asm	/^vector153:$/;"	l
vector153	vectors.S	/^vector153:$/;"	l
vector154	kernel.asm	/^vector154:$/;"	l
vector154	vectors.S	/^vector154:$/;"	l
vector155	kernel.asm	/^vector155:$/;"	l
vector155	vectors.S	/^vector155:$/;"	l
vector156	kernel.asm	/^vector156:$/;"	l
vector156	vectors.S	/^vector156:$/;"	l
vector157	kernel.asm	/^vector157:$/;"	l
vector157	vectors.S	/^vector157:$/;"	l
vector158	kernel.asm	/^vector158:$/;"	l
vector158	vectors.S	/^vector158:$/;"	l
vector159	kernel.asm	/^vector159:$/;"	l
vector159	vectors.S	/^vector159:$/;"	l
vector16	kernel.asm	/^vector16:$/;"	l
vector16	vectors.S	/^vector16:$/;"	l
vector160	kernel.asm	/^vector160:$/;"	l
vector160	vectors.S	/^vector160:$/;"	l
vector161	kernel.asm	/^vector161:$/;"	l
vector161	vectors.S	/^vector161:$/;"	l
vector162	kernel.asm	/^vector162:$/;"	l
vector162	vectors.S	/^vector162:$/;"	l
vector163	kernel.asm	/^vector163:$/;"	l
vector163	vectors.S	/^vector163:$/;"	l
vector164	kernel.asm	/^vector164:$/;"	l
vector164	vectors.S	/^vector164:$/;"	l
vector165	kernel.asm	/^vector165:$/;"	l
vector165	vectors.S	/^vector165:$/;"	l
vector166	kernel.asm	/^vector166:$/;"	l
vector166	vectors.S	/^vector166:$/;"	l
vector167	kernel.asm	/^vector167:$/;"	l
vector167	vectors.S	/^vector167:$/;"	l
vector168	kernel.asm	/^vector168:$/;"	l
vector168	vectors.S	/^vector168:$/;"	l
vector169	kernel.asm	/^vector169:$/;"	l
vector169	vectors.S	/^vector169:$/;"	l
vector17	kernel.asm	/^vector17:$/;"	l
vector17	vectors.S	/^vector17:$/;"	l
vector170	kernel.asm	/^vector170:$/;"	l
vector170	vectors.S	/^vector170:$/;"	l
vector171	kernel.asm	/^vector171:$/;"	l
vector171	vectors.S	/^vector171:$/;"	l
vector172	kernel.asm	/^vector172:$/;"	l
vector172	vectors.S	/^vector172:$/;"	l
vector173	kernel.asm	/^vector173:$/;"	l
vector173	vectors.S	/^vector173:$/;"	l
vector174	kernel.asm	/^vector174:$/;"	l
vector174	vectors.S	/^vector174:$/;"	l
vector175	kernel.asm	/^vector175:$/;"	l
vector175	vectors.S	/^vector175:$/;"	l
vector176	kernel.asm	/^vector176:$/;"	l
vector176	vectors.S	/^vector176:$/;"	l
vector177	kernel.asm	/^vector177:$/;"	l
vector177	vectors.S	/^vector177:$/;"	l
vector178	kernel.asm	/^vector178:$/;"	l
vector178	vectors.S	/^vector178:$/;"	l
vector179	kernel.asm	/^vector179:$/;"	l
vector179	vectors.S	/^vector179:$/;"	l
vector18	kernel.asm	/^vector18:$/;"	l
vector18	vectors.S	/^vector18:$/;"	l
vector180	kernel.asm	/^vector180:$/;"	l
vector180	vectors.S	/^vector180:$/;"	l
vector181	kernel.asm	/^vector181:$/;"	l
vector181	vectors.S	/^vector181:$/;"	l
vector182	kernel.asm	/^vector182:$/;"	l
vector182	vectors.S	/^vector182:$/;"	l
vector183	kernel.asm	/^vector183:$/;"	l
vector183	vectors.S	/^vector183:$/;"	l
vector184	kernel.asm	/^vector184:$/;"	l
vector184	vectors.S	/^vector184:$/;"	l
vector185	kernel.asm	/^vector185:$/;"	l
vector185	vectors.S	/^vector185:$/;"	l
vector186	kernel.asm	/^vector186:$/;"	l
vector186	vectors.S	/^vector186:$/;"	l
vector187	kernel.asm	/^vector187:$/;"	l
vector187	vectors.S	/^vector187:$/;"	l
vector188	kernel.asm	/^vector188:$/;"	l
vector188	vectors.S	/^vector188:$/;"	l
vector189	kernel.asm	/^vector189:$/;"	l
vector189	vectors.S	/^vector189:$/;"	l
vector19	kernel.asm	/^vector19:$/;"	l
vector19	vectors.S	/^vector19:$/;"	l
vector190	kernel.asm	/^vector190:$/;"	l
vector190	vectors.S	/^vector190:$/;"	l
vector191	kernel.asm	/^vector191:$/;"	l
vector191	vectors.S	/^vector191:$/;"	l
vector192	kernel.asm	/^vector192:$/;"	l
vector192	vectors.S	/^vector192:$/;"	l
vector193	kernel.asm	/^vector193:$/;"	l
vector193	vectors.S	/^vector193:$/;"	l
vector194	kernel.asm	/^vector194:$/;"	l
vector194	vectors.S	/^vector194:$/;"	l
vector195	kernel.asm	/^vector195:$/;"	l
vector195	vectors.S	/^vector195:$/;"	l
vector196	kernel.asm	/^vector196:$/;"	l
vector196	vectors.S	/^vector196:$/;"	l
vector197	kernel.asm	/^vector197:$/;"	l
vector197	vectors.S	/^vector197:$/;"	l
vector198	kernel.asm	/^vector198:$/;"	l
vector198	vectors.S	/^vector198:$/;"	l
vector199	kernel.asm	/^vector199:$/;"	l
vector199	vectors.S	/^vector199:$/;"	l
vector2	kernel.asm	/^vector2:$/;"	l
vector2	vectors.S	/^vector2:$/;"	l
vector20	kernel.asm	/^vector20:$/;"	l
vector20	vectors.S	/^vector20:$/;"	l
vector200	kernel.asm	/^vector200:$/;"	l
vector200	vectors.S	/^vector200:$/;"	l
vector201	kernel.asm	/^vector201:$/;"	l
vector201	vectors.S	/^vector201:$/;"	l
vector202	kernel.asm	/^vector202:$/;"	l
vector202	vectors.S	/^vector202:$/;"	l
vector203	kernel.asm	/^vector203:$/;"	l
vector203	vectors.S	/^vector203:$/;"	l
vector204	kernel.asm	/^vector204:$/;"	l
vector204	vectors.S	/^vector204:$/;"	l
vector205	kernel.asm	/^vector205:$/;"	l
vector205	vectors.S	/^vector205:$/;"	l
vector206	kernel.asm	/^vector206:$/;"	l
vector206	vectors.S	/^vector206:$/;"	l
vector207	kernel.asm	/^vector207:$/;"	l
vector207	vectors.S	/^vector207:$/;"	l
vector208	kernel.asm	/^vector208:$/;"	l
vector208	vectors.S	/^vector208:$/;"	l
vector209	kernel.asm	/^vector209:$/;"	l
vector209	vectors.S	/^vector209:$/;"	l
vector21	kernel.asm	/^vector21:$/;"	l
vector21	vectors.S	/^vector21:$/;"	l
vector210	kernel.asm	/^vector210:$/;"	l
vector210	vectors.S	/^vector210:$/;"	l
vector211	kernel.asm	/^vector211:$/;"	l
vector211	vectors.S	/^vector211:$/;"	l
vector212	kernel.asm	/^vector212:$/;"	l
vector212	vectors.S	/^vector212:$/;"	l
vector213	kernel.asm	/^vector213:$/;"	l
vector213	vectors.S	/^vector213:$/;"	l
vector214	kernel.asm	/^vector214:$/;"	l
vector214	vectors.S	/^vector214:$/;"	l
vector215	kernel.asm	/^vector215:$/;"	l
vector215	vectors.S	/^vector215:$/;"	l
vector216	kernel.asm	/^vector216:$/;"	l
vector216	vectors.S	/^vector216:$/;"	l
vector217	kernel.asm	/^vector217:$/;"	l
vector217	vectors.S	/^vector217:$/;"	l
vector218	kernel.asm	/^vector218:$/;"	l
vector218	vectors.S	/^vector218:$/;"	l
vector219	kernel.asm	/^vector219:$/;"	l
vector219	vectors.S	/^vector219:$/;"	l
vector22	kernel.asm	/^vector22:$/;"	l
vector22	vectors.S	/^vector22:$/;"	l
vector220	kernel.asm	/^vector220:$/;"	l
vector220	vectors.S	/^vector220:$/;"	l
vector221	kernel.asm	/^vector221:$/;"	l
vector221	vectors.S	/^vector221:$/;"	l
vector222	kernel.asm	/^vector222:$/;"	l
vector222	vectors.S	/^vector222:$/;"	l
vector223	kernel.asm	/^vector223:$/;"	l
vector223	vectors.S	/^vector223:$/;"	l
vector224	kernel.asm	/^vector224:$/;"	l
vector224	vectors.S	/^vector224:$/;"	l
vector225	kernel.asm	/^vector225:$/;"	l
vector225	vectors.S	/^vector225:$/;"	l
vector226	kernel.asm	/^vector226:$/;"	l
vector226	vectors.S	/^vector226:$/;"	l
vector227	kernel.asm	/^vector227:$/;"	l
vector227	vectors.S	/^vector227:$/;"	l
vector228	kernel.asm	/^vector228:$/;"	l
vector228	vectors.S	/^vector228:$/;"	l
vector229	kernel.asm	/^vector229:$/;"	l
vector229	vectors.S	/^vector229:$/;"	l
vector23	kernel.asm	/^vector23:$/;"	l
vector23	vectors.S	/^vector23:$/;"	l
vector230	kernel.asm	/^vector230:$/;"	l
vector230	vectors.S	/^vector230:$/;"	l
vector231	kernel.asm	/^vector231:$/;"	l
vector231	vectors.S	/^vector231:$/;"	l
vector232	kernel.asm	/^vector232:$/;"	l
vector232	vectors.S	/^vector232:$/;"	l
vector233	kernel.asm	/^vector233:$/;"	l
vector233	vectors.S	/^vector233:$/;"	l
vector234	kernel.asm	/^vector234:$/;"	l
vector234	vectors.S	/^vector234:$/;"	l
vector235	kernel.asm	/^vector235:$/;"	l
vector235	vectors.S	/^vector235:$/;"	l
vector236	kernel.asm	/^vector236:$/;"	l
vector236	vectors.S	/^vector236:$/;"	l
vector237	kernel.asm	/^vector237:$/;"	l
vector237	vectors.S	/^vector237:$/;"	l
vector238	kernel.asm	/^vector238:$/;"	l
vector238	vectors.S	/^vector238:$/;"	l
vector239	kernel.asm	/^vector239:$/;"	l
vector239	vectors.S	/^vector239:$/;"	l
vector24	kernel.asm	/^vector24:$/;"	l
vector24	vectors.S	/^vector24:$/;"	l
vector240	kernel.asm	/^vector240:$/;"	l
vector240	vectors.S	/^vector240:$/;"	l
vector241	kernel.asm	/^vector241:$/;"	l
vector241	vectors.S	/^vector241:$/;"	l
vector242	kernel.asm	/^vector242:$/;"	l
vector242	vectors.S	/^vector242:$/;"	l
vector243	kernel.asm	/^vector243:$/;"	l
vector243	vectors.S	/^vector243:$/;"	l
vector244	kernel.asm	/^vector244:$/;"	l
vector244	vectors.S	/^vector244:$/;"	l
vector245	kernel.asm	/^vector245:$/;"	l
vector245	vectors.S	/^vector245:$/;"	l
vector246	kernel.asm	/^vector246:$/;"	l
vector246	vectors.S	/^vector246:$/;"	l
vector247	kernel.asm	/^vector247:$/;"	l
vector247	vectors.S	/^vector247:$/;"	l
vector248	kernel.asm	/^vector248:$/;"	l
vector248	vectors.S	/^vector248:$/;"	l
vector249	kernel.asm	/^vector249:$/;"	l
vector249	vectors.S	/^vector249:$/;"	l
vector25	kernel.asm	/^vector25:$/;"	l
vector25	vectors.S	/^vector25:$/;"	l
vector250	kernel.asm	/^vector250:$/;"	l
vector250	vectors.S	/^vector250:$/;"	l
vector251	kernel.asm	/^vector251:$/;"	l
vector251	vectors.S	/^vector251:$/;"	l
vector252	kernel.asm	/^vector252:$/;"	l
vector252	vectors.S	/^vector252:$/;"	l
vector253	kernel.asm	/^vector253:$/;"	l
vector253	vectors.S	/^vector253:$/;"	l
vector254	kernel.asm	/^vector254:$/;"	l
vector254	vectors.S	/^vector254:$/;"	l
vector255	kernel.asm	/^vector255:$/;"	l
vector255	vectors.S	/^vector255:$/;"	l
vector26	kernel.asm	/^vector26:$/;"	l
vector26	vectors.S	/^vector26:$/;"	l
vector27	kernel.asm	/^vector27:$/;"	l
vector27	vectors.S	/^vector27:$/;"	l
vector28	kernel.asm	/^vector28:$/;"	l
vector28	vectors.S	/^vector28:$/;"	l
vector29	kernel.asm	/^vector29:$/;"	l
vector29	vectors.S	/^vector29:$/;"	l
vector3	kernel.asm	/^vector3:$/;"	l
vector3	vectors.S	/^vector3:$/;"	l
vector30	kernel.asm	/^vector30:$/;"	l
vector30	vectors.S	/^vector30:$/;"	l
vector31	kernel.asm	/^vector31:$/;"	l
vector31	vectors.S	/^vector31:$/;"	l
vector32	kernel.asm	/^vector32:$/;"	l
vector32	vectors.S	/^vector32:$/;"	l
vector33	kernel.asm	/^vector33:$/;"	l
vector33	vectors.S	/^vector33:$/;"	l
vector34	kernel.asm	/^vector34:$/;"	l
vector34	vectors.S	/^vector34:$/;"	l
vector35	kernel.asm	/^vector35:$/;"	l
vector35	vectors.S	/^vector35:$/;"	l
vector36	kernel.asm	/^vector36:$/;"	l
vector36	vectors.S	/^vector36:$/;"	l
vector37	kernel.asm	/^vector37:$/;"	l
vector37	vectors.S	/^vector37:$/;"	l
vector38	kernel.asm	/^vector38:$/;"	l
vector38	vectors.S	/^vector38:$/;"	l
vector39	kernel.asm	/^vector39:$/;"	l
vector39	vectors.S	/^vector39:$/;"	l
vector4	kernel.asm	/^vector4:$/;"	l
vector4	vectors.S	/^vector4:$/;"	l
vector40	kernel.asm	/^vector40:$/;"	l
vector40	vectors.S	/^vector40:$/;"	l
vector41	kernel.asm	/^vector41:$/;"	l
vector41	vectors.S	/^vector41:$/;"	l
vector42	kernel.asm	/^vector42:$/;"	l
vector42	vectors.S	/^vector42:$/;"	l
vector43	kernel.asm	/^vector43:$/;"	l
vector43	vectors.S	/^vector43:$/;"	l
vector44	kernel.asm	/^vector44:$/;"	l
vector44	vectors.S	/^vector44:$/;"	l
vector45	kernel.asm	/^vector45:$/;"	l
vector45	vectors.S	/^vector45:$/;"	l
vector46	kernel.asm	/^vector46:$/;"	l
vector46	vectors.S	/^vector46:$/;"	l
vector47	kernel.asm	/^vector47:$/;"	l
vector47	vectors.S	/^vector47:$/;"	l
vector48	kernel.asm	/^vector48:$/;"	l
vector48	vectors.S	/^vector48:$/;"	l
vector49	kernel.asm	/^vector49:$/;"	l
vector49	vectors.S	/^vector49:$/;"	l
vector5	kernel.asm	/^vector5:$/;"	l
vector5	vectors.S	/^vector5:$/;"	l
vector50	kernel.asm	/^vector50:$/;"	l
vector50	vectors.S	/^vector50:$/;"	l
vector51	kernel.asm	/^vector51:$/;"	l
vector51	vectors.S	/^vector51:$/;"	l
vector52	kernel.asm	/^vector52:$/;"	l
vector52	vectors.S	/^vector52:$/;"	l
vector53	kernel.asm	/^vector53:$/;"	l
vector53	vectors.S	/^vector53:$/;"	l
vector54	kernel.asm	/^vector54:$/;"	l
vector54	vectors.S	/^vector54:$/;"	l
vector55	kernel.asm	/^vector55:$/;"	l
vector55	vectors.S	/^vector55:$/;"	l
vector56	kernel.asm	/^vector56:$/;"	l
vector56	vectors.S	/^vector56:$/;"	l
vector57	kernel.asm	/^vector57:$/;"	l
vector57	vectors.S	/^vector57:$/;"	l
vector58	kernel.asm	/^vector58:$/;"	l
vector58	vectors.S	/^vector58:$/;"	l
vector59	kernel.asm	/^vector59:$/;"	l
vector59	vectors.S	/^vector59:$/;"	l
vector6	kernel.asm	/^vector6:$/;"	l
vector6	vectors.S	/^vector6:$/;"	l
vector60	kernel.asm	/^vector60:$/;"	l
vector60	vectors.S	/^vector60:$/;"	l
vector61	kernel.asm	/^vector61:$/;"	l
vector61	vectors.S	/^vector61:$/;"	l
vector62	kernel.asm	/^vector62:$/;"	l
vector62	vectors.S	/^vector62:$/;"	l
vector63	kernel.asm	/^vector63:$/;"	l
vector63	vectors.S	/^vector63:$/;"	l
vector64	kernel.asm	/^vector64:$/;"	l
vector64	vectors.S	/^vector64:$/;"	l
vector65	kernel.asm	/^vector65:$/;"	l
vector65	vectors.S	/^vector65:$/;"	l
vector66	kernel.asm	/^vector66:$/;"	l
vector66	vectors.S	/^vector66:$/;"	l
vector67	kernel.asm	/^vector67:$/;"	l
vector67	vectors.S	/^vector67:$/;"	l
vector68	kernel.asm	/^vector68:$/;"	l
vector68	vectors.S	/^vector68:$/;"	l
vector69	kernel.asm	/^vector69:$/;"	l
vector69	vectors.S	/^vector69:$/;"	l
vector7	kernel.asm	/^vector7:$/;"	l
vector7	vectors.S	/^vector7:$/;"	l
vector70	kernel.asm	/^vector70:$/;"	l
vector70	vectors.S	/^vector70:$/;"	l
vector71	kernel.asm	/^vector71:$/;"	l
vector71	vectors.S	/^vector71:$/;"	l
vector72	kernel.asm	/^vector72:$/;"	l
vector72	vectors.S	/^vector72:$/;"	l
vector73	kernel.asm	/^vector73:$/;"	l
vector73	vectors.S	/^vector73:$/;"	l
vector74	kernel.asm	/^vector74:$/;"	l
vector74	vectors.S	/^vector74:$/;"	l
vector75	kernel.asm	/^vector75:$/;"	l
vector75	vectors.S	/^vector75:$/;"	l
vector76	kernel.asm	/^vector76:$/;"	l
vector76	vectors.S	/^vector76:$/;"	l
vector77	kernel.asm	/^vector77:$/;"	l
vector77	vectors.S	/^vector77:$/;"	l
vector78	kernel.asm	/^vector78:$/;"	l
vector78	vectors.S	/^vector78:$/;"	l
vector79	kernel.asm	/^vector79:$/;"	l
vector79	vectors.S	/^vector79:$/;"	l
vector8	kernel.asm	/^vector8:$/;"	l
vector8	vectors.S	/^vector8:$/;"	l
vector80	kernel.asm	/^vector80:$/;"	l
vector80	vectors.S	/^vector80:$/;"	l
vector81	kernel.asm	/^vector81:$/;"	l
vector81	vectors.S	/^vector81:$/;"	l
vector82	kernel.asm	/^vector82:$/;"	l
vector82	vectors.S	/^vector82:$/;"	l
vector83	kernel.asm	/^vector83:$/;"	l
vector83	vectors.S	/^vector83:$/;"	l
vector84	kernel.asm	/^vector84:$/;"	l
vector84	vectors.S	/^vector84:$/;"	l
vector85	kernel.asm	/^vector85:$/;"	l
vector85	vectors.S	/^vector85:$/;"	l
vector86	kernel.asm	/^vector86:$/;"	l
vector86	vectors.S	/^vector86:$/;"	l
vector87	kernel.asm	/^vector87:$/;"	l
vector87	vectors.S	/^vector87:$/;"	l
vector88	kernel.asm	/^vector88:$/;"	l
vector88	vectors.S	/^vector88:$/;"	l
vector89	kernel.asm	/^vector89:$/;"	l
vector89	vectors.S	/^vector89:$/;"	l
vector9	kernel.asm	/^vector9:$/;"	l
vector9	vectors.S	/^vector9:$/;"	l
vector90	kernel.asm	/^vector90:$/;"	l
vector90	vectors.S	/^vector90:$/;"	l
vector91	kernel.asm	/^vector91:$/;"	l
vector91	vectors.S	/^vector91:$/;"	l
vector92	kernel.asm	/^vector92:$/;"	l
vector92	vectors.S	/^vector92:$/;"	l
vector93	kernel.asm	/^vector93:$/;"	l
vector93	vectors.S	/^vector93:$/;"	l
vector94	kernel.asm	/^vector94:$/;"	l
vector94	vectors.S	/^vector94:$/;"	l
vector95	kernel.asm	/^vector95:$/;"	l
vector95	vectors.S	/^vector95:$/;"	l
vector96	kernel.asm	/^vector96:$/;"	l
vector96	vectors.S	/^vector96:$/;"	l
vector97	kernel.asm	/^vector97:$/;"	l
vector97	vectors.S	/^vector97:$/;"	l
vector98	kernel.asm	/^vector98:$/;"	l
vector98	vectors.S	/^vector98:$/;"	l
vector99	kernel.asm	/^vector99:$/;"	l
vector99	vectors.S	/^vector99:$/;"	l
vectors	vectors.S	/^vectors:$/;"	l
version	elf.h	/^  uint version;$/;"	m	struct:elfhdr
version	mp.h	/^  uchar version;                \/\/ I\/O APIC version$/;"	m	struct:mpioapic
version	mp.h	/^  uchar version;                \/\/ [14]$/;"	m	struct:mpconf
version	mp.h	/^  uchar version;                \/\/ local APIC verison$/;"	m	struct:mpproc
virt	vm.c	/^  void *virt;$/;"	m	struct:kmap	file:
void	bootblock.asm	/^void readseg(uchar*, uint, uint);$/;"	l
void	bootblock.asm	/^void$/;"	l
void	cat.asm	/^void$/;"	l
void	echo.asm	/^void$/;"	l
void	grep.asm	/^void$/;"	l
void	init.asm	/^void$/;"	l
void	kernel.asm	/^void$/;"	l
void	kill.asm	/^void$/;"	l
void	ln.asm	/^void$/;"	l
void	ls.asm	/^void$/;"	l
void	mkdir.asm	/^void$/;"	l
void	rm.asm	/^void$/;"	l
void	sh.asm	/^void$/;"	l
void	wc.asm	/^void$/;"	l
void	zombie.asm	/^void$/;"	l
volatile	kernel.asm	/^volatile uint *lapic;  \/\/ Initialized in mp.c$/;"	l
w	console.c	/^  uint w;  \/\/ Write index$/;"	m	struct:__anon3	file:
wait	proc.c	/^wait(void)$/;"	f
waitdisk	bootmain.c	/^waitdisk(void)$/;"	f
wakeup	proc.c	/^wakeup(void *chan)$/;"	f
wakeup1	proc.c	/^wakeup1(void *chan)$/;"	f	file:
walkpgdir	vm.c	/^walkpgdir(pde_t *pgdir, const void *va, int alloc)$/;"	f	file:
wc	wc.c	/^wc(int fd, char *name)$/;"	f
whitespace	sh.c	/^char whitespace[] = " \\t\\r\\n\\v";$/;"	v
winode	mkfs.c	/^winode(uint inum, struct dinode *ip)$/;"	f
writable	file.h	/^  char writable;$/;"	m	struct:file
write	file.h	/^  int (*write)(struct inode*, char*, int);$/;"	m	struct:devsw
write_head	log.c	/^write_head(void)$/;"	f	file:
writei	fs.c	/^writei(struct inode *ip, char *src, uint off, uint n)$/;"	f
writeopen	pipe.c	/^  int writeopen;  \/\/ write fd is still open$/;"	m	struct:pipe	file:
wrv	kernel.asm	/^  wrv = (ushort*)P2V((0x40<<4 | 0x67));  \/\/ Warm reset vector$/;"	d
wsect	mkfs.c	/^wsect(uint sec, void *buf)$/;"	f
x	cat.asm	/^    x = -xx;$/;"	d
x	cat.asm	/^    x = xx;$/;"	d
x	echo.asm	/^    x = -xx;$/;"	d
x	echo.asm	/^    x = xx;$/;"	d
x	grep.asm	/^    x = -xx;$/;"	d
x	grep.asm	/^    x = xx;$/;"	d
x	init.asm	/^    x = -xx;$/;"	d
x	init.asm	/^    x = xx;$/;"	d
x	kernel.asm	/^    x = -xx;$/;"	d
x	kernel.asm	/^    x = xx;$/;"	d
x	kill.asm	/^    x = -xx;$/;"	d
x	kill.asm	/^    x = xx;$/;"	d
x	ln.asm	/^    x = -xx;$/;"	d
x	ln.asm	/^    x = xx;$/;"	d
x	ls.asm	/^    x = -xx;$/;"	d
x	ls.asm	/^    x = xx;$/;"	d
x	mkdir.asm	/^    x = -xx;$/;"	d
x	mkdir.asm	/^    x = xx;$/;"	d
x	rm.asm	/^    x = -xx;$/;"	d
x	rm.asm	/^    x = xx;$/;"	d
x	sh.asm	/^    x = -xx;$/;"	d
x	sh.asm	/^    x = xx;$/;"	d
x	umalloc.c	/^  Align x;$/;"	m	union:header	file:
x	wc.asm	/^    x = -xx;$/;"	d
x	wc.asm	/^    x = xx;$/;"	d
x	zombie.asm	/^    x = -xx;$/;"	d
x	zombie.asm	/^    x = xx;$/;"	d
xchecksum	mp.h	/^  uchar xchecksum;              \/\/ extended table checksum$/;"	m	struct:mpconf
xchg	x86.h	/^xchg(volatile uint *addr, uint newval)$/;"	f
xint	mkfs.c	/^xint(uint x)$/;"	f
xlength	mp.h	/^  ushort xlength;               \/\/ extended table length$/;"	m	struct:mpconf
xshort	mkfs.c	/^xshort(ushort x)$/;"	f
xticks	kernel.asm	/^  xticks = ticks;$/;"	d
yield	proc.c	/^yield(void)$/;"	f
zeroes	mkfs.c	/^char zeroes[512];$/;"	v
